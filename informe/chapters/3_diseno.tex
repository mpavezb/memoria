\chapter{Diseño}\label{chapter:diseno}


En este capítulo se revisa el diseño del sistema LTM implementado en el proyecto. Primero, se presentan todos los requerimientos de diseño y se elabora un conjunto de validaciones que permitirán guiar el diseño, implementación y posterior evaluación del proyecto. Mediante las siguientes 4 secciones se describe la arquitectura del sistema: Se revisa el diseño de los episodios, su estructura de datos y limitantes. Luego se estudia el diseño del modelo de datos para la memoria episódica y su relación con los componentes semánticos. En tercer lugar se presenta el diseño del servidor LTM y sus limitantes. Finalmente, se definen la interfaz episódica y los componentes específicos a implementar para el robot Bender.

\todounsure{Es correcto hablar de plugins?.. o debo usar ``complementos''?}


\todoimprove{Modificar ocurrencias de campos What, When, Where por versiones \texttt{What, When, Where}} 

\section{Requerimientos y validaciones}

A continuación se presentan los requisitos de diseño sobre los que se construye el proyecto y las validaciones generadas a partir de ellos. Primero se da una descripción breve sobre el origen y razón de los requisitos. Luego, se presenta un listado formal de todos los requerimientos, escritos de una forma clara y verificable. Para concluir, se presenta un conjunto de pruebas que busca validar cada requerimiento expuesto.
 
\subsection{Requisitos de usuario}

\todounsure{Está bien hablar sobre ``requisitos de usuario''??.. en realidad casi todos fueron inventados por mi durante la propuesta!! Yo soy mi propio cliente O.O ... }

\todounsure{Qué tan formal debo ser con la especificación de req. usuario y req. software?? Si soy ultra formal (estilo curso Ing.Soft II) tendría que poner un documento de requisitos en los anexos.. mucha pega sin sentido?. Sólo quiero graduarme :'( }
%\subsubsection{Requisitos de capacidad}
%\subsubsection{Requisitos de calidad}
%\subsubsection{Requisitos de restricción}

El primer conjunto de requisitos se obtiene a partir de los objetivos del proyecto y sus alcances:
\begin{itemize}
\item Diseño de LTM (episódica y semántica) para robots de servicio domésticos.
\item Implementación integrada en Bender, compatible con su sistema.
\item Dar demostración de funcionalidades introducidas.
\item Énfasis en diseño de sistema genérico y compatible con más robots.
\item Memoria emocional debe ser soportada por el diseño, a pesar de no ser implementada.
\end{itemize}

El siguiente conjunto de requisitos corresponde a los 11 requerimientos para una memoria EpLTM planteados por Stachowicz\cite{Stachowicz2012} y presentados en la Sección \ref{sec:mem_robotica}. 

El sistema de relevancia episódica es importante para habilitar búsquedas de episodios según su importancia. En primer lugar, el sistema debe soportar el concepto de relevancia histórica de episodios, similarmente a lo estudiado por XXX \cite{} y presentado en la sección \ref{}. En cuanto a la relevancia emocional, el sistema debe permitir indexar episodios mediante este concepto. Además, se debe considerar que existen diversos sistemas de manejo de emociones, y el diseño no debe ser restrictivo respecto a ello. Finalmente, los episodios deben manejar un indicador de relevancia, que encapsule todos los demás indicadores en solo uno.
\todowrite{Al parecer, en el marco teórico no se habla sobre la relevancia histórica ni las metodologías para unir las relevancias.}
\todopaused{El indicador conjunto de relevancias aún no ha sido implementado}

\subsubsection{Alcances del proyecto}

\todounsure{Es necesario hablar sobre cosas que NO SON REQUISITOS??}

Para acotar el diseño, implementación y validaciones, a continuación se presenta un listado requerimientos que no pertenecen al proyecto actual, sino que son considerados como trabajo futuro.

\begin{itemize}
\item Mecanismos para olvido o represión (en caso de contenido emocional traumático).
\item Problemas éticos sobre almacenar datos de usuarios.
\item Inferencia de información a partir de episodios almacenados.
\item Inferencia de episodios según sucesos previos y posteriores, como lo propuesto por Kelley \cite{Kelley2014} y estudiado en la Sección \ref{}.
\item Indicador de relevancia por novedad del episodio, basado en similitud con episodios ya existentes. No es de interés, pues se puede abstraer al módulo emocional.
\item Modificar conversaciones que mantiene el robot con humanos, según los datos episódicos almacenados (e.g., si se está hablando sobre una entidad nueva o ya conocida).
\item Eliminación automática de datos para liberar recursos de memoria secundaria.
\end{itemize}
\todounsure{En un principio se gastó tiempo con knowrob y prolog... que hago respecto a esto?? lo agrego al informe??... quito la inferencia de los objetivos secundarios??... donde escribo esto?}

\subsection{Requerimientos de software}

A continuación se presenta un listado (semiformal) de requisitos de software, generados a partir de los requisitos de usuario revisados en la sección anterior. Cada requisito de fue reformulado desde su versión difusa, a una descripción más precisa y verificable del requerimiento original. 
\todounsure{Debo dar excusa sobre la informalidad del formato de presentación de requisitos?? Dan un poco de pena respecto a los visto en ING. Soft II, por ejemplo: link a requisito de usuario.. separación por tipo de requisito.. metadatos del requisito... matriz de trazabilidad... etc}

\paragraph{RS01}
El sistema debe ser agnóstico respecto a la plataforma objetivo. No se puede asumir que estructuras de datos semánticas serán almacenadas para cada episodio. Debe permitir que usuarios definan las estructuras de datos semánticas a almacenar.

\paragraph{RS02}
El servidor debe ser implantado en el robot Bender. Debe ser agregado al proceso de instalación y su documentación.Debe ser configurado para ser ejecutado simultáneamente a los otros módulos.

\paragraph{RS03}
Se deben implementar instancias de cada componente genérico, enfocadas en el robot Bender.
\begin{itemize}
	\item Implementación de la interfaz para adquisición de episodios basados en librería SMACH.
	\item Implementación de memoria semántica adecuada al robot: Información sobre personas y objetos.
	\item El software dedicado al robot debe ser implementado en paquetes de ROS distintos del utilizado para el servidor LTM.
\end{itemize}

\paragraph{RS04}
El servidor debe ser compatible con ROS, mediante una API ROS para acceder a todas sus funcionalidades.

\paragraph{RS05}
El servidor debe proveer servicios para las operaciones CRUD sobre los episodios manejados.

\paragraph{RS06}
Los episodios almacenados deben estar conectados bidireccionalmente con los datos semánticos relacionados.

\paragraph{RS07}
(R1) Episodios deben contener campo What, para almacenar memoria semántica. Ya que la memoria semántica es definida por el usuario, éste campo debe poder almacenar cualquier tipo de información.

\paragraph{RS08}
(R1) Episodios deben contener campo When, para almacenar tiempos de inicio y finalización del episodio. Debe poder manejar intervalos de tiempo desde segundos a años.

\paragraph{RS09}
(R1) Episodios deben contener campo Where, para almacenar información sobre la ubicación del robot durante su ocurrencia.

\paragraph{RS10}
(R2) Episodios deben ser indexados al menos por los campos What, When y Where.
\todounsure{Cómo valido esto?}

\paragraph{RS11}
(R2) El servidor debe permitir realizar búsquedas de episodios con condiciones sobre la información almacenada para What, When, Where. Las condiciones de búsqueda deben permitir comparaciones {igualdad, mayor que, pertenencia} entre tipos de dato básicos {strings, números, bool}, asociados a los campos del episodio.

\paragraph{RS12}
(R3) Los episodios pueden crear entidades semánticas o actualizar las ya existentes.

\paragraph{RS13}
(R4)  Cada episodio ingresado a la memoria es único, a pesar de que existan similitudes con otros episodios.

\paragraph{RS14}
(R5) A partir de un episodio se puede acceder a episodios padre e hijos.

\paragraph{RS15}
(R6)  Lecturas de episodios deben mostrar la memoria semántica como se conocía en ese instante. Es decir, resultado de la consulta debe mostrar los campos asociados a entidades, como si nunca más hubieran cambiado.)

\paragraph{RS16}
(R7) Episodios pueden estar compuestos de sub-episodios.

\paragraph{RS17}
(R8) Pueden existir episodios simultáneos, y con distintos tiempos de inicio y fin.

\paragraph{RS18}
(R9) Se deben minimizar las dependencias de módulos de software externos para el funcionamiento del servidor. Particularmente:
El sistema debe ser implementado en ROS y solamente utilizando las librerías estándar de Python y C++. La única excepción corresponde a la librería para el manejo de la base de datos a utilizar.
No deben existir dependencias extra para los módulos de memoria semántica definidos por el usuario, ni para la representación de la memoria semántica.

\paragraph{RS19}
(R9) En caso que ya exista información semántica almacenada, los usuarios deben poder modificar su representación.

\paragraph{RS20}
(R10) El servidor debe tolerar una alta tasa de generación de eventos, sin degradar el funcionamiento del robot. Específicamente:
\todoimprove{Esos valores de recursos fueron escogidos al azar!.. deben ser modificados.}
\begin{itemize}
	\item El funcionamiento base del sistema, es decir, con el servidor en ejecución y sin consultas funcionando, no debe exceder el uso del 15\% del CPU y 15\% de RAM del la plataforma objetivo.
	\item Debe poder manejar al menos la generación de 10 eventos simultáneamente, sin exceder un aumento en el uso de recursos de un 10\%, relativo al costo de su funcionamiento base.
	\item En caso de que el robot tenga más del 90\% de sus recursos de CPU ocupados, el sistema debe entrar en modo de bajo consumo, y encolar los episodios para posterior almacenamiento.
\end{itemize}


\paragraph{RS21}
(R11) Costos de operaciones CRUD deben escalar bien, respecto a la cantidad de datos almacenados. Particularmente, el costo en tiempo de las operaciones debe estar acotado en $O(n\ log\ n)$ respecto a la cantidad de episodios almacenados.

\paragraph{RS22}
Episodios deben tener un indicador numérico de relevancia histórica, el que debe ser degradado automáticamente con el paso del tiempo.

\paragraph{RS23}
Episodios deben tener, al menos, la siguiente información sobre la emoción del robot asociada al episodio: nombre de la emoción principal asociada, e indicador numérico que identifique la intensidad de la emoción. La estructura de datos y formato utilizado no debe depender de algún software emocional externo.

\paragraph{RS24}
Episodios deben tener un indicador numérico de relevancia episódica generalizado, que una los subsistemas de relevancia en sólo uno. El indicador debe ser actualizado automáticamente cuando cualquiera de los subindicadores sea actualizado.

\paragraph{RS25}
El robot Bender no dispone de módulos para el cómputo de emociones. Se deben implementar al menos 3 sistemas de generación de emociones para el robot, los que deben ser utilizados para la demostración.

\paragraph{RS26}
Episodios deben estar indexados por los siguientes indicadores numéricos de relevancia, sumado a la descripción de la emoción. Se deben poder realizar búsquedas utilizando éstos índices.

\todolater{Requisito sobre que la implementación de la interfaz episódica implementada en SMACH debe ser lo menos instrusiva posible.}

\todolater{Requisito sobre que la implementación de la interfaz episódica implementada en SMACH no debe fallar / colgarse / arrojar excepciones por ningún motivo, para no sacrificar el funcionamiento del robot en caso de errores.}

\subsection{Validaciones}

A continuación se presenta un conjunto de validaciones para la implementación del sistema. Éstas son generadas directamente desde los requisitos planteados anteriormente, y además sirven como guía para el diseño e implementación del proyecto. Éstas se separan en 5 categorías: 1. Validaciones que se verifican directamente desde el diseño e implementación del sistema, 2. validaciones mediante la ejecución del sistema, 3. validaciones mediante consultas episódicas al servidor, 4. validaciones de eficiencia, y 5. validaciones de escalabilidad.

\todoimprove{listado formal de validaciones basadas en requerimientos}

\subsubsection{Validaciones por diseño e implementación}
\paragraph{VA01 (RS01)}
% estado [OK]
Verificar que el que el proyecto no tiene ninguna dependencia en software propio del robot.

\paragraph{VA02 (RS01)}
% estado [OK]
Verificar que el servidor admite la definición de estructuras de datos genéricas para la información semántica.

\paragraph{VA03 (RS02)}
% estado [PENDING]
Verificar que el sistema LTM se encuentra documentado en la documentación del robot. La documentación debe incluir tutoriales de instalación y uso del sistema.

\paragraph{VA04 (RS03)}
% estado [PENDING]
Verificar que existan implementaciones de entidades semánticas para personas y objetos.

\paragraph{VA05 (RS03)}
% estado [OK]
Verificar que módulos de software implementados sean separados en al menos 2 paquetes de ROS. El primero debe contener el servidor LTM sin ninguna dependencia al robot. El resto debe contener los módulos extra implementados y deben depender del primero.

\paragraph{VA06 (RS07)}
% estado [OK]
Verificar que el campo What de un episodio pueda almacenar cualquier estructura de datos que ROS sea capaz de manejar.

\paragraph{VA07 (RS08)}
% estado [OK]
Verificar que episodios poseen campo When, para almacenar tiempo de inicio y finalización del episodio

\paragraph{VA08 (RS13)}
% estado [OK]
Verificar que cada nuevo episodio disponga de un ID único entre el resto de los episodios ya almacenados.

\paragraph{VA09 (RS18)}
% estado [OK]
Verificar que el paquete de ROS que implementa el servidor sólo tenga como dependencias: librerías estándar de C++ y Python, driver de la base de datos, paquetes estándar de ROS.


\paragraph{VA10 (RS23)}
% estado [OK]
Verificar que estructura de datos emocional sólo está compuesta por tipos de datos disponibles entre los del estándar en ROS. Verificar que el sistema LTM sólo dependa de la intensidad de la emoción y nombre asociado para la implementación de sus funcionalidades.


\subsubsection{Validaciones mediante ejecución}

\paragraph{VB01 (RS02)}
% estado:  [PENDING]
Verificar que el sistema LTM se instala correctamente en conjunto con la instalación del robot.

\paragraph{VB02 (RS02)}
% estado:  [PENDING]
Verificar que tras iniciar el software base del robot, se encuentre activo el servidor LTM y sus API ROS.

\paragraph{VB03 (RS03)}
% estado:  [OK]
Verificar que servidor almacena episodios generados a partir de la interfaz con SMACH. Se debe verificar que un set de máquinas de estado ejecutadas sea procesado correctamente.

\paragraph{VB04 (RS04)}
% estado:  [OK]
Verificar que el paquete ROS provee herramientas para lanzar el servidor.

\paragraph{VB05 (RS04)}
% estado:  [OK]
Verificar que el servidor provee API ROS para configurar sus parámetros.

\paragraph{VB06 (RS05)}
% estado:  [PENDING]
Verificar que el servidor activo provee API ROS para agregar, buscar, actualizar y borrar episodios. 

\paragraph{VB07 (RS25)}
% estado:  [PENDING]
Verificar que existan implementados al menos 3 módulos generadores de emociones para el robot Bender. Éstos deben utilizar sensores disponibles en el robot. Los módulos deben pertenecer a un paquete de ROS dedicado.


\subsubsection{Validaciones mediante consultas al servidor}

\paragraph{VC01 (RS03)}
% estado:  [TOO BROAD]
Consultas relacionadas a entidades de personas y objetos!
.
\todowrite{PENDIENTE}


\paragraph{VC02 (RS06)}
% estado:  [PENDING]
Obtener un episodio desde el servidor. A partir de él, acceder a datos semánticos definidos. Verificar que se pueda obtener referencia al episodio a partir de los datos semánticos obtenidos.

\paragraph{VC03 (RS06)}
% estado:  [PENDING]
Obtener una entidad desde el servidor. A partir de ella, listar todos los episodios relacionados.

\paragraph{VC04 (RS08)}
% estado:  [OK]
Verificar que el servidor permita almacenar episodios con duraciones de segundos, horas, días y años.

\paragraph{VC05 (RS09)}
% estado:  [TOO BROAD]
Verificar que episodios contengan campo Where. Almacenar episodios utilizando distintas ubicaciones.
.
\todowrite{PENDIENTE}


\paragraph{VC06 (RS11)}
% estado:  [PENDING]
Test R02: Search: Buscar episodios indexados por W-1.
Test R03: Search: Buscar episodios indexados por W-2.
Test R04: Search: Buscar episodios indexados por W-3.
.
\todowrite{PENDIENTE}


\paragraph{VC07 (RS12)}
% estado:  [PENDING]
(R3 Flexibilidad)
Test R05: Preguntar por datos aprendidos posteriormente.
A: Interactúa con (a) y lo almacena.
B: Interactúa con (a) o (b) y aprende dato sobre (a).
C: Consulta sobre (a) muestra nuevo dato.
Test R06: Preguntar por datos modificados posteriormente.
A: Interactúa con (a) y lo almacena.
B: Interactúa con (a) o (b) y modifica dato sobre (a).
C: Consulta sobre (a) muestra dato modificado.
.
\todowrite{PENDIENTE}

\paragraph{VC08 (RS14)}
% estado:  [OK]
Obtener un episodio desde el servidor. A partir de sus datos consultar por su episodio padre y episodios hijos.

\paragraph{VC09 (RS15)}
% estado:  [PENDING]
(R6: Perspectiva)
Test R10: Eventos recordados deben mantener perspectiva de la experiencia original.
Episodio A: Habla con (a). Almacena que es estudiante de colegio.
Episodio B: Habla con (a). Almacena que es estudiante de U.
Recordar A: debe decir que (a) era estudiante de colegio.
Recordar B: debe decir que (b) era estudiante universitario. 
.
\todowrite{PENDIENTE}

\paragraph{VC10 (RS16)}
% estado:  [OK]
Test R11: Evento A con sub evento B (temporalmente)
.
\todowrite{PENDIENTE}


\paragraph{VC11 (RS17)}
% estado:  [OK]
Generar dos eventos transpuestos en tiempo (campo \texttt{When}). Verificar que al obtener ambos eventos, sus datos sean correctos y no se haya mezclado la información semántica asociada.


\paragraph{VC12 (RS19)}
% estado:  [PENDING]
Crear entidad semántica para el test con estructura A. Crear e ingresar M episodios que ocupen la estructura A. Modificar entidad y dejar en estructura B. Ingresar N episodios que utilicen estructura B. Realizar búsquedas de episodios con estructura A y de episodios con estructura B.


\paragraph{VC13 (RS22)}
% estado:  [PENDING]
Generar episodios con antigüedades en el rango de 1 segundo hasta 5 años, espaciados por intervalos de horas (para los 24 primeros) y días, para los (365) siguientes y semanas para el resto. Forzar actualización de relevancias, leer todos los episodios y graficar su relevancia histórica, para verificar que es decreciente.

\paragraph{VC14 (RS23)}
% estado:  [PENDING]
Consultar algún episodio de la base de datos. Verificar que dispone de campos de relevancia emocional: Indicador numérico para la intensidad de la emoción, y descripción de la emoción.

\paragraph{VC15 (RS24)}
% estado:  [PENDING]
Consultar algún episodio de la base de datos. Verificar que dispone de un indicador numérico con la relevancia generalizada.
\begin{itemize}
\item Verificar que al disminuir la relevancia histórica del episodio, la relevancia generalizada también disminuya.
\item Manteniendo las otras relevancias fijas. Verificar que episodios con mayor/menor relevancia emocional muestran una mayor/menor relevancia generalizada.
\item Manteniendo las otras relevancias fijas. Verificar que episodios con mayor/menor relevancia histórica muestran una mayor/menor relevancia generalizada.
\end{itemize}

\paragraph{VC16 (RS25)}
% estado:  [PENDING]
Generar episodios en donde se ocupe cada uno de los módulos generadores de emociones implementados para el robot Bender.

\paragraph{VC17 (RS26)}
% estado:  [PENDING]
Generar episodios con distintos índices de relevancia histórica, emocional y generalizada. Verificar que se puedan realizar búsquedas de episodios mediante cada uno de los indicadores de relevancia, sumado a la descripción de la emoción.

\subsubsection{Validaciones de eficiencia}

\todopaused{Reescribir validaciones una vez estas se hayan ejecutado!.}

\todoimprove{Revisar pruebas de eficiencia de Stachowicz \cite{Stachowicz2012}, y Vijayakumar \cite{Vijayakumar2014}. Agregar referencia a sus evaluaciones.}

\todowrite{Escribir en algún lado a que me refiero con estado/funcionamiento base.}

Las siguientes validaciones tienen por objetivo medir la eficiencia del sistema LTM una vez implementado, y se construyen a partir del requisito de software (RS20). Cada una busca medir el uso de algún recurso del sistema, mientras el servidor se encuentra en funcionamiento y en espera. 

Se deben realizar las siguientes mediciones:
\begin{enumerate}
\item Uso de CPU y RAM cuando el servidor está en estado base.
\item Uso de CPU, RAM y ancho de banda de disco, para consultas de búsqueda episódica (simples) a tasas de \{0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}[Hz].
\item Uso de CPU, RAM y ancho de banda de disco, para consultas de búsqueda episódica (complejas) a tasas de \{0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}[Hz].
\item Uso de CPU, RAM y ancho de banda de disco, para servicio de ingreso de episodios (sin información semántica), a tasas de \{0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}[Hz].
\item Uso de CPU, RAM y ancho de banda de disco, para servicio de ingreso de episodios (con información semántica), a tasas de \{0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}[Hz].
\end{enumerate}
\todoimprove{hablar sobre simple/complejo es muy subjetivo.}

\paragraph{VD01 (RS20)}
En primer lugar, se debe validar que en estado base, el uso de CPU y RAM no exceda al 15\% del total disponible para el robot Bender.

\paragraph{VD02 (RS20)}
Se debe verificar que las operaciones de búsqueda no sobrepasen el uso de recursos en un 10\%, respecto al costo del funcionamiento base. Es decir, se admite hasta un 25\% del uso del total de recursos disponibles para el robot.
\todoimprove{Actualizar requerimiento para considerar ancho de banda del disco y agregar validación asociada.}

\paragraph{VD03 (RS20)}
Verificar que si al menos un 90\% de los recursos de CPU del robot se encuentran ocupados, el servidor LTM entra en modo de bajo consumo. En éste modo, el servidor no puede ocupar más del 5\% de recursos extra a los de su estado base, y todas las consultas deben ser postergadas.
\todoimprove{Corregir esto: no tiene sentido postergar consultas de búsqueda.. sólo las de inserción!... (acumular episodios en RAM mientras) por último quitar este requerimiento!.}


\subsubsection{Validaciones de escalabilidad}

Las siguientes conjuntos de validaciones se construyen a partir del requisito de software (RS21). Tienen por objetivo medir el costo de tiempo de las operaciones de inserción, búsqueda y borrado de episodios, en función de la cantidad de episodios almacenados en la base de datos. En cada una se busca validar que la complejidad temporal de las operaciones se comporte de la forma $\mathcal{O}(n\log{}n)$.

\todoimprove{Revisar pruebas de escalabilidad de Stachowicz \cite{Stachowicz2012}, y Vijayakumar \cite{Vijayakumar2014}. Agregar referencia a sus evaluaciones.}

\todoimprove{Verificar que complejidad escogida tiene sentido!.}

\begin{itemize}
\item {\bf VE01 (RS21)}: Tiempo de búsqueda vs. cantidad de episodios, según el campo \textit{What}
\item {\bf VE02 (RS21)}: Tiempo de búsqueda vs. cantidad de episodios, según el campo \textit{Where}
\item {\bf VE03 (RS21)}: Tiempo de búsqueda vs. cantidad de episodios, según el campo \textit{When}
\item {\bf VE04 (RS21)}: Tiempo de búsqueda vs. cantidad de episodios, según el campo \textit{What, When, Where}
\item {\bf VE05 (RS21)}: Tiempo de inserción vs. cantidad de episodios.
\item {\bf VE06 (RS21)}: Tiempo de borrado vs. cantidad de episodios.
\end{itemize}
\todounsure{Quizás las validaciones de búsqueda tienen más sentido al buscar por el tipo del campo (número, string, bool)}
\todounsure{Quizás las validaciones de inserción deban ser separadas en casos con pocos-muchos streams-entidades... y caso en vacío... Finalmente todo dependerá de la calidad de la implementación del usuario.. pero tiene sentido validar los plugins que si se implementarán en el robot.}
\todounsure{Creo que el tiempo de borrado no tiene sentido!, actualización quizás... pero no es una operación común... las operaciones comunes deben ser sólo inserción y búsqueda}

\todounsure{No estoy seguro si tiene sentido agregar validaciones de escalabilidad en el uso de recursos del sistema: CPU, RAM, DISCO}
%El segundo conjunto estudia el uso de recursos del sistema: CPU, disco y RAM.
%\paragraph{VE07 (RS21)}: disk usage vs. \# episodes
%\paragraph{VE08 (RS21)}: RAM usage vs. \# episodes
%\paragraph{VE09 (RS21)}: CPU usage vs. \# episodes



% ==============================================================================
% ==============================================================================
\section{Diseño de episodios}
% ==============================================================================
% ==============================================================================

A continuación presentan las decisiones de diseño seguidas para la representación de los datos episódicos mediante mensajes de ROS. Se estudia el formato a utilizar para el almacenamiento de cada episodio, seguido de la estructura de datos tipo árbol, diseñada para representar el anidamiento episódico. Luego se explica el diseño de los campos episódicos (\textit{What, When, Where}), la representación de la memoria semántica y el manejo de relevancias episódicas. Finalmente, se introducen los metadatos asociados a cada episodio y las limitantes del diseño episódico desarrollado para la representación episódica.

\todolater{Agregar listado de mensajes y servicios en los anexos.}

\subsection{Formato y representación}

% SOBRE ELECCIÓN DE MENSAJES DE ROS
\paragraph{Mensaje ROS:}
Se decidió utilizar mensajes de ROS para la representación de episodios. Esto se justifica en la amplia gama de mensajes preconstruidos que provee, los que permiten generar un mensaje adecuado a cualquier necesidad. Además, al utilizar éste sistema de mensajes, se evita definir una formato de información particular para la representación episódica, y la comunicación de episodios mediante la API ROS del servidor se simplifica. Más aún, como se explicará en más detalle en la Sección \ref{}, el driver para MongoDB a utilizar permite almacenar cualquier estructura de datos, mientras ésta esté encapsulada en un mensaje ROS.

% SOBRE UNICIDAD
\paragraph{Unicidad:}
El requisito de software \hl{(RSXX)} exige que cada episodio sea único. Para esto, el mensaje ROS debe contener un campo que identifique al episodio. El servidor debe encargarse de que cada nuevo episodio cuente con un identificador único.

% SOBRE CAMPO DE TAGS
\paragraph{Tags:}
Además, para simplificar la búsqueda y reconocimiento de episodios, se incluye un campo de \textit{tags}. Éste corresponde a un vector de \textit{strings} y permite almacenar descripciones breves sobre la naturaleza del episodio. Por ejemplo, un episodio podría contener los siguientes \textit{tags}: ``cumpleaños'', ``fiesta'', ``atender invitados'' y ``torta''.

\paragraph{Representación:}
Luego, se construye un nuevo mensaje de ROS, \texttt{Episode.msg}, al cual se le agregan los siguientes campos:
\begin{itemize}
\item Campo \texttt{uint32 uid}: Sirve para indicar el identificador único asignado al episodio.
\item Campo \texttt{string[] tags}: Vector de tags, para almacenar todos los \textit{tags} asociados al episodio.
\end{itemize}

 
\subsection{Árboles de episodios}

\todounsure{Quitar manejo de contexto del trabajo??... no se si vale la pena que el server maneje ese concepto. Puede ser trabajo futuro.}

\todounsure{Es correcto hablar de hojas y nodos??... Debo buscar una palabra más adecuada para nodos que no son hojas??.. o debo explicitar que en adelante, cualquier referencia a nodo se refiere a eso. Suena raro hablar de ``padres''.}

% SOBRE ANIDACIÓN Y ÁRBOLES EPISÓDICOS
\paragraph{Anidamiento episódico:}
A partir del requisito de software \hl{(RSXX)}, se debe soportar el concepto de anidación episódica. Este nace de la capacidad para expresar cualquier episodio, en términos de 1 o más sub-episodios más específicos. Para ello, se definen los \textit{árboles de episodios}, utilizando una estructura de datos de árbol: Las hojas contienen todo episodio que el sistema identifica como no divisible, mientras que cada padre es una representación menos específica de lo sucedido.

% SOBRE TEMPORALIDAD
\paragraph{Temporalidad:}
Para el árbol episódico, es fundamental que cada episodio padre inicie antes que cualquiera de sus hijos, y termine después que todos ellos. 

% SOBRE MANEJO DE INFORMACIÓN EN PADRES E HIJOS
\paragraph{Estrategia de almacenamiento:}
Ya que un padre puede ser representado lógicamente por su conjunto de hijos, se decide utilizar una metodología de almacenamiento que no genere redundancia de información. Sólo las hojas del árbol son las encargadas de manejar la información semántica del episodio, lo que potencialmente corresponde a una gran cantidad de información. Asimismo, las hojas son encargadas de manejar la mayor cantidad de información episódica que sea posible. Las estrategias para esto serán explicadas en sus respectivas secciones. Por lo tanto, los nodos del árbol manejan poca información y la mayor parte de sus datos puede ser calculada recursivamente a partir de sus hijos y de manera automática por el servidor.

% SOBRE EL CONTEXTO
\paragraph{Noción de contexto:}
Es importante enfatizar que no basta que un episodio esté embebido temporalmente en otro para ser considerado un hijo. Pues a pesar de cumplir la condición de temporalidad, puede ocurrir el caso de que ambos episodios sean simultáneos, pero estén ligados a un contexto distinto. Por ejemplo, dado un episodio A (robot está participando la competencia RoboCup - días de duración) y un episodio B (durante la competencia, robot es utilizado para una tarea de uno de los estudiantes, lo que es considerado ajeno a la competencia); a pesar de que A contiene temporalmente a B, se puede decir que B pertenece a otro contexto y debe ser almacenado en un árbol distinto. Esta noción de contexto es importante, y es la razón por la que el servidor debe manejar una cantidad indefinida de árboles episódicos, cada uno identificado por su raíz. Debido lo anterior, cada episodio debe ser almacenado indicando quien es el padre asociado.

% SOBRE EL MSG ROS
\paragraph{Representación:}
Finalmente, tomando en cuanta las consideraciones anteriores, se agregan los ajustes siguientes al mensaje de ROS:
\begin{itemize}
\item Campo \texttt{uint32 parent\_id}: Sirve para indicar el campo \texttt{uid} del padre del episodio. Se reserva el valor $0$ de éste campo para representar el padre de un episodio raíz.
\item Campo \texttt{uint32[] children\_ids}: Vector de \texttt{uid} asociadas a los episodios hijos. No existe condición sobre el orden temporal de los episodios hijos.
\item Campo \texttt{uint8 type}: Sirve para indicar si el episodio debe ser considerado como hoja o nodo del árbol.
\item Campo \texttt{string[] children\_tags}: Vector que sirve para acceder rápidamente a todos los \texttt{tags} definidos en los hijos. Se reserva el campo \texttt{tags}, para dar descripciones asociadas solamente al episodio actual.
\end{itemize}
 
\todoimplementation{Se puede agregar condición de que hijos son ordenados por tiempo de inicio}
 
\subsection{Contexto temporal: \textit{When}}\label{sec:design_ep_when}

% SOBRE LOS REQUISITOS
\paragraph{Requisitos:}
De acuerdo al requisito de software \hl{(RSXX)}, los episodios deben almacenar información que indique su contexto temporal (\textit{When}), es decir, cuándo  sucedió. Para esto, la única información de interés a almacenar son los instantes de tiempo que indican el fin y el inicio del episodio.

\todoimplementation{Revisar o modificar implementación.. no estoy seguro como se están manejando los tiempos para los padres... lo lógico sería no ajustar los tiempos a los de los hijos, pues estos pueden no estar definidos hasta el final!... O agregarlo como limitante.}
% SOBRE MANEJO DE INFORMACIÓN
\paragraph{Estrategia de almacenamiento:}
En el caso de las hojas del árbol, basta utilizar los instantes de tiempo obtenidos al iniciar y finalizar el episodio. Sin embargo, para el caso de los \hl{nodos}, se pueden seguir dos estrategias: Utilizar los instantes de tiempo iniciales y finales percibidos, o calcular automáticamente los tiempos de inicio y fin para ajustarse a los hijos. A pesar de que la segunda opción suena razonable, está asumiendo que siempre existirá un hijo para cada instante de tiempo de vida del padre, lo que puede no ser cierto. Por lo tanto, se deben manejar cuidadosamente los valores de tiempo de los padres, para asegurar que no son sobre-escritos por sus hijos, y para asegurar que los padres siempre contienen temporalmente a cada hijo.

% SOBRE EL MENSAJE ROS
\paragraph{Representación:}
Entonces, se crea el mensaje \texttt{When.msg} para almacenar el contexto temporal del episodio, con los siguientes campos:
\begin{itemize}
	\item \texttt{time start}\footnote{El tipo de dato \texttt{time} es estándar en ROS y permite indicar un instante de tiempo mediante un contador de segundos transcurridos desde el tiempo cero (Jueves 1 de Enero de 1970 a las 00:00:00). Tiene una resolución de nanosegundos.}: Indica el instante en que se inicia el episodio.
	\item \texttt{time end}: Indica el instante en que finaliza el episodio.
\end{itemize}

Y el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/When when}\footnote{El dominio \texttt{ltm/} hace referencia al nombre del paquete ROS donde se implementa el servidor y que contiene la definición de todos los mensajes relacionados.}: Se agrega una instancia del mensaje \texttt{When.msg}, para manejar el contexto temporal del episodio.
\end{itemize}

 
\subsection{Contexto espacial: \textit{Where}}

% SOBRE LOS REQUISITOS
\paragraph{Requisitos:}
De acuerdo al requisito de software \hl{(RSXX)}, los episodios deben almacenar información que indique su contexto espacial (\textit{Where}), es decir, dónde sucedió. A continuación se explican las decisiones de diseño consideradas.

% SOBRE DURACIÓN DE EPISODIOS Y VECTORES
\paragraph{Desplazamiento durante episodios:}
En primer lugar, dependiendo de la duración del episodio, el robot puede haber estado en más de un lugar durante ese tiempo. Esto no es válido sólo para episodios nodo, sino que también para hojas, cuando éstas representan acciones de desplazamiento del robot. Luego, es importante que cada episodio registre cada uno de los lugares en los que ha estado el robot. El listado de lugares debe ser almacenado ordenadamente y con la hora asociada a cada desplazamiento, lo que es importante por dos motivos: permite calcular la secuencia de movimientos para los padres, y permite reconstruir la ruta del robot durante cada episodio. Para ello, la posición del robot puede ser consultada periódicamente en busca de cambios, para almacenar sólo los instantes que indiquen movimiento.
\todoimplementation{Soportar más de 1 lugar semántico y coordenado para hijos.}


% SOBRE USO DE AMBAS OPCIONES: Lugares y coordenadas
\paragraph{Estrategias de almacenamiento:}
La información espacial puede ser manejada de dos maneras: se pueden almacenar los nombres de los lugares en donde el robot estuvo durante el episodio, o se puede almacenar la ubicación precisa del robot durante el episodio, mediante coordenadas relativas a un sistema coordenado predefinido. La decisión sobre cual sistema utilizar depende mucho del contexto en el cual funciona el robot. Por ejemplo, en el caso de Bender, hay ocasiones en donde sólo es posible conocer su ubicación respecto a un sistema coordenado, mientras que en otras oportunidades, sólo se tiene conocimiento verbal de ésta. Luego, ya que no existe un consenso sobre que opción es la mejor, y para evitar limitar la usabilidad del sistema LTM, se decidió dar soporte a ambas alternativas.
\todounsure{Todo todo todo debe estar en 3ra persona singular presente??? como hablo de decisiones pasadas??... según esto, corregir todos los párrafos.}

% OPCIÓN SEMÁNTICA
\paragraph{Estrategia 1 - Descripción:}
Los nombres de lugares en los que estuvo el robot durante el episodio pueden ser almacenados utilizando vectores de \textit{strings}. Considerando el ambiente en donde puede desempeñarse un robot de servicio doméstico, se decide almacenar esta información en dos niveles de profundidad. El primer nivel corresponde a una descripción específica de la ubicación del robot (ej., ``Comedor''), mientras que el segundo sirve para almacenar el nombre del área donde se encuentra la primera ubicación (ej., ``Casa de John''), junto a otras de similar tamaño semántico. En el caso de los episodios nodo, se ha decidido calcular automáticamente toda esta información, a partir de los episodios hijo.
\todoimplementation{Crear submensaje para Where.msg, que almacene: location, area, time}

% OPCIÓN COORDENADAS
\paragraph{Estrategia 2 - Coordenadas:}
Similarmente al caso anterior, las coordenadas de lugares son almacenadas en vectores de puntos, junto con su hora y sistema de coordenadas asociados. Además, para cada punto se debe almacenar el nombre del mapa en donde se define el sistema coordenado. Ya que el proyecto está orientado a robots de servicio doméstico, se ha decidido implementar solamente ubicaciones en 2 dimensiones, es decir, cada punto sólo considera 2 valores numéricos. En el caso de los padres se sigue la siguiente estrategia: las posiciones son obtenidas a partir de sus hijos, se agrega un campo para almacenar la envoltura convexa de todas las posiciones, y se agrega un campo indicando el centroide de ésta.
\todoimplementation{Modificar implementación para agregar soporte a más de un frame/mapa.}
\todoimplementation{Crear submensaje para Where.msg, que represente ubicación coordenada múltiple}

% SOBRE MENSAJE EPISODICO
\paragraph{Representación:}
Considerando el diseño estudiado, se crea el mensaje \texttt{Where.msg} para almacenar el contexto espacial del episodio, utilizando los siguientes campos:
\todopaused{Actualizar estos datos de acuerdo a la modificación que se hará al sistema.}
\begin{itemize}
\item \texttt{geometry\_msgs/Point position}\footnote{El paquete de ROS \texttt{geometry\_msgs} proporciona mensajes para manejar primitivas geométricas y sus transformaciones. Pertenece al conjunto de paquetes para mensajes \texttt{common\_msgs}, el cual se considera estable. Más información en la web oficial: \url{http://wiki.ros.org/geometry\_msgs}}: Mensaje que permite definir la posición del robot durante la ocurrencia del episodio. A pesar de que el tipo de dato permite definir 3 coordenadas, sólo se consideran los campos \texttt{position.x} y \texttt{position.y}. En el caso de ser un nodo del árbol, corresponde al centroide del campo \texttt{children\_hull}.
\item \texttt{string frame\_id}: Indica el nombre del sistema de coordenadas sobre el cual se define el campo \texttt{position}.
\item \texttt{string map\_name}: Indica el nombre del mapa utilizado, en el cual se ubican la posición descrita y el sistema de coordenadas elegido. 
\item \texttt{string location}: Nombre del lugar donde se encontraba el robot al momento del episodio.
\item \texttt{string area}: Nombre del área en donde se ubica el lugar descrito por \texttt{location}. 
\item \texttt{geometry\_msgs/Point[] children\_hull}:
\item \texttt{string[] children\_locations}:
\item \texttt{string[] children\_areas}:
\end{itemize}


Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
\item \texttt{ltm/Where where}: Se agrega una instancia del mensaje \texttt{Where.msg}, para manejar el contexto espacial del episodio.
\end{itemize}


\subsection{Memoria semántica: \textit{What}}

% REQUISITOS
\paragraph{Requisitos:}
De acuerdo a los requisitos de software \hl{(RSXXX), (RSXXX)}, la memoria semántica (\textit{What}) ligada a un episodio permite describir `qué'' sucedió en él. Ésta debe poder  contener cualquier dato, por lo que no es posible establecer de antemano qué información y estructura debe ser utilizada, sino que ésto debe poder ser definido por el usuario. El requisito \hl{(RSXXX)} (regla de flexibilidad episódica) establece que cada episodio debe permitir crear nuevos datos semánticos o actualizar los ya existentes. El requisito \hl{(RSXXX)} (regla de perspectiva episódica) exige que al leer un episodio, éste pueda describir sus datos semánticos asociados, de acuerdo a la misma perspectiva que se tenía de ellos cuando el episodio fue ejecutado.


% SEPARACIÓN DE CONCEPTOS
\paragraph{Streams y entidades:} 
La memoria semántica maneja entidades conocidas por el robot e información sobre ellas. Por ejemplo, se puede definir la entidad ``persona'' y almacenar datos como su nombre, nacionalidad o la fecha de la última interacción registrada. Sin embargo, existe un tipo de información que no está asociada a alguna entidad en particular, correspondiente a datos en forma de flujos de información (\textit{streams}). Éstos permiten registrar secuencias de imágenes, sonido y otros conceptos basados en flujos de datos percibidos por el robot, especialmente los obtenidos directamente desde sus sensores. Otra característica de los \textit{streams}, es que a diferencia de las entidades, representan datos que no se desea actualizar posteriormente, pues almacenan una imagen de lo percibido en el instante, la que generalmente es invariable. Entonces, se decide separar la memoria semántica en dos componentes, \textit{streams} y entidades, lo que permite diseñar estrategias de procesamiento adecuadas al funcionamiento de cada uno.


% GENERALIZANDO MEMORIA SEMÁNTICA
\paragraph{Generalización:}
Ya que los contenidos a almacenar deben poder ser definidos por el usuario, se establecen las siguientes decisiones de diseño. En primer lugar, el usuario debe definir que información utilizará, mediante uno o más mensajes de ROS. Segundo, éstos mensajes deben tener un campo para almacenar un identificador único. Los episodios deben tener referencias al tipo del mensaje asociado y a sus identificadores únicos. Similarmente, cada mensaje definido debe tener un campo para almacenar el identificador único de su episodio relacionado. Lo anterior es válido tanto para \textit{streams} como entidades.

\todopaused{Episodio almacena tags para describir entidades y cambios?.}


% SOBRE PLUGINS
\paragraph{Sistema de plugins:}
Se decidió utilizar un sistema basado en \textit{plugins}, para manejar los mensajes ROS definidos por el usuario. El diseño del servidor LTM en la Sección \ref{} especifica que funcionalidades deben ser implementadas por \textit{plugins} destinados a \textit{streams} o entidades. De esta manera, se delega al usuario la implementación de los algoritmos para adquisición de información semántica y procesamiento de ésta.


% SOBRE STREAMS
\paragraph{Datos semánticos - Streams:}
Los \textit{streams} corresponden a flujos de datos generalmente invariables. Cada episodio puede estar asociado a uno o más \textit{streams}, y a su vez, cada \textit{stream} puede contener uno o más datos. El servidor debe proveer notificaciones para indicar el inicio y fin de un episodio, mientras que el usuario debe definir su estrategia para adquirir datos durante ese lapso de tiempo. Por ejemplo, en el caso de un \textit{stream} de imágenes representando la visión del robot, y cuyo fin sólo sea de visualización a futuro, el usuario podría almacenar una imagen cada 3 segundos. 

Según la cantidad de \textit{plugins} a utilizar y la periodicidad de recopilación de información, el espacio de disco requerido para almacenar los mensajes puede ser agotado rápidamente. Para solucionar esto hay 3 alternativas. En primer lugar, se puede expandir la memoria disponible, lo que no es una solución real. En segundo lugar, está el ``olvido'' de información, mediante la eliminación de datos antiguos (posiblemente previo respaldo en otra máquina) o eliminar datos intercaladamente. La tercera opción es la degradación de información, para lo que cada usuario debe implementar un algoritmo que disminuya el tamaño de sus mensajes (por ejemplo, disminuyendo la resolución o cantidad de las imágenes del episodio). Ya que las dos primeras opciones pueden ser ejecutadas manualmente por el usuario, se ha decidido utilizar la degradación de mensajes. Esta estrategia puede ser aplicada automáticamente a mensajes antiguos y de baja relevancia episódica.

\todoimplementation{LTM server con warning en texto y notificación inotify cuando quede poco espacio de disco (menor a X\%) (o se ha ocupado más de X GB) debido al server... configurable por usuario...}


% SOBRE ENTIDADES
\paragraph{Datos semánticos - Entidades:}
% - manejo de datos y relaciones para regla perspectiva
% - manejo de datos y relaciones para flexibilidad
.

\todoimplementation{Manejo de perspectiva y audit al requerir insertar episodio al medio (temporalmente) de otros ya existentes.}

\todopaused{Escribir tras tener primera implementación razonable}



\subsection{Manejo de relevancia generalizada}

% RELEVANCIA GENERALIZADA
\paragraph{Requisitos:}
De acuerdo a los requisitos de software \hl{(RSXX), (RSXX) y (RSXX)}, los episodios deben almacenar información de relevancia episódica. Estos indicadores son importantes al momento de buscar episodios, para poder ordenarlos de acuerdo a una medida de importancia, y así tener una pista sobre cuales enfocar la atención. El sistema debe soportar, al menos, la noción de relevancia histórica y emocional, considerando que en un futuro se podrían agregar otros indicadores de relevancia. También, el sistema debe proveer un indicador generalizado, capaz de representar la relevancia global del episodio, mediante un solo indicador numérico que unifique las sub-relevancias.


% MANEJO DE INDICADORES
\paragraph{Estrategia de almacenamiento:}
Entonces, se define la siguiente estrategia de almacenamiento. Cada tipo de indicador debe proveer un valor numérico en el rango $[0, 1]$, que represente la importancia del episodio de acuerdo a su perspectiva. Un valor de 0 significa que el episodio no es relevante, mientras que el valor 1 es utilizado para indicar que el episodio es muy importante. Utilizando el formato anterior, se construye el indicador de relevancia generalizada a partir de todas las sub-relevancias definidas para el episodio. Este indicador debe ser actualizado cada vez que una sub-relevancia sea modificada o ingresada.


% COMPUTO BASADO EN ALGORITMO X
\paragraph{Cómputo:}
Este proyecto sólo considera dos sub-indicadores, histórico y emocional, por lo que se decidió utilizar la metodología propuesta por \hl{XXX} \cite{} y explicada en la Sección \ref{}.
\todopaused{Escribir más cuando esté implementado}


% MSG ROS
\paragraph{Representación:}
Luego, se crea un mensaje de tipo \texttt{Relevance.msg}, para almacenar las sub-relevancias del episodio y la relevancia generalizada. El mensaje es creado como sigue:
\begin{itemize}
\item TODO
\end{itemize}
\todopaused{Agregar representación de relevancia generalizada, una vez que sea implementada.}

Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/Relevance relevance}: Se agrega una instancia del mensaje \texttt{Relevance.msg}, para almacenar toda la información relacionada a los indicadores de relevancia del episodio.
\end{itemize}


\subsection{Manejo de relevancia emocional}

% RELEVANCIA EMOCIONAL
\paragraph{Requisitos:}
El requisito de software \hl{(RSXXX)} exige el manejo del concepto de relevancia emocional, como un medio para almacenar las emociones ``que tiene'' el robot durante un episodio, en conjunto a un indicador de la intensidad de éstas.


% ABSTRACCIÓN DEL SISTEMA DE EMOCIONES
% - sobre EMOCIONES VÁLIDAS
\paragraph{Abstracción del sistema emocional:}
Según se revisó en la Sección \ref{}, existen diversas sistemas emocionales para la generación de emociones. No existe una metodología única para el cómputo de emociones, por lo que cada sistema es alimentado con datos diferentes, utilizan algoritmos distintos y proveen salidas distintas. Debido a la generalidad esperada de este proyecto, la forma de representar la emoción es se abstrae del sistema emocional a utilizar. Para esto, en primer lugar se define un conjunto de emociones base, a partir del modelo emocional de Plutchik descrito en la Sección \ref{}, con las que se debe construir la emoción asociada al episodio, mediante una combinación de ellas. Luego, se decidió utilizar un sistema de plugins, para que el usuario defina cómo realizar la asignación desde las salidas de su sistema emocional, a la combinación de emociones base disponibles para un episodio. Es así, como la asignación emocional se puede  abstraer de la implementación y delegar al usuario encargado de la plataforma objetivo.


% CAMPOS REQUERIDOS
\paragraph{Estrategia de almacenamiento:}
En primer lugar, se define un conjunto de 8 emociones base para la representación emocional (alegría, confianza, miedo, sorpresa, tristeza, disgusto, enfado y anticipación). El diseño considera sólo el almacenamiento de la emoción más importante durante la duración del episodio, la que es asociada a una emoción del conjunto base. Luego, siguiendo el estándar definido para representación de relevancias, se agrega un valor numérico en el rango $[0, 1]$, para  indicar la intensidad de la emoción seleccionada. Para el caso de episodios nodo, el valor emocional es calculado automáticamente a partir de los hijos. Para esto, se utiliza un vector de 8 valores, destinados a cada una de las 8 emociones base, donde se almacena el valor máximo de cada emoción presentado por sus hijos.

% METADATOS
\paragraph{Metadatos:}
Además, para simplificar la introspección de episodios a futuro, se decide agregar metadatos para indicar: software emocional utilizado y su versión, conjunto de salidas registradas por el software emocional y sus valores de intensidad. Es importante enfatizar que estos datos sólo deben ser utilizados para introspección y no tienen influencia en el cálculo de ninguna relevancia.
\todolater{Actualizar esto en caso de modificar metadatos}

% MSG ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{EmotionalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
\item \texttt{int32 emotion}: Valor que hace referencia a una de las 8 emociones base. En el caso de episodios nodo, hace referencia a la emoción con mayor relevancia.
\item \texttt{float32 value}: Intensidad de la emoción seleccionada. Válido para episodios nodo y hojas.
\item \texttt{int32[] children\_emotions}: Vector con identificadores de las 8 emociones base. Sólo es utilizado por episodios nodo.
\item \texttt{float32[] children\_values}: Vector con intensidades de cada una de las 8 emociones base. Sólo es utilizado por episodios nodo.
\item \texttt{string software}: Metadato. Nombre del sistema emocional utilizado.
\item \texttt{string software\_version}: Metadato. Versión del sistema emocional utilizado.
\item \texttt{string[] registered\_emotions}: Metadato. Descripción de emociones encontradas por el software generador de emociones. 
\item \texttt{float32[] registered\_values}: Metadato. Intensidades de emociones descritas en el campo \texttt{registered\_emotions}.
\end{itemize}


Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/EmotionalRelevance emotional}: Se agrega una instancia del mensaje ROS de tipo \texttt{EmotionalRelevance.msg}, para almacenar la información emocional relativa al episodio.
\end{itemize}


\subsection{Manejo de relevancia histórica}

% SOBRE RELEVANCIA HISTORICA
\paragraph{Requisitos:}
El requisito de software \hl{(RSXXX)} exige el manejo del concepto de relevancia histórica, como un medio para indicar la importancia de un episodio, según su edad en la base de datos. 

% ALMACENAMIENTO
\paragraph{Estrategia de almacenamiento:}
Siguiendo el estándar definido para representación de relevancias, se utiliza un valor numérico en el rango $[0, 1]$, para  indicar el estado de envejecimiento del episodio. Este valor siempre debe ser inicializado en 1, para decaer hacia 0 con el paso del tiempo.


% MANEJO AUTOMÁTICO DE DATOS HISTÓRICOS
\paragraph{Actualización automática:}
El valor de la relevancia debe ser manejado automáticamente por el servidor LTM. Existen diversas formas de actualizar este valor, pero tras una revisión bibliográfica, se decidió utilizar la siguiente estrategia. Se propone disminuir el indicador, según el algoritmo de decaimiento estudiado por XXX en \cite{} y presentado en la Sección \ref{}. Ya que se espera almacenar una gran cantidad de episodios, se propone actualizar el valor cada lapsos cada vez más espaciados en el tiempo (por ejemplo, primero cada 1 día, luego 1 vez a la semana, cada 1 mes, cada 1 año), lo que permite acotar el esfuerzo computacional dedicado a las actualizaciones.

\todopaused{Sobre la tasa de decaimiento histórica implementada.}

% MENSAJE ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{HistoricalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{float32 value}: Indicador numérico de la relevancia histórica del episodio.
	\item \texttt{ltm/Date last\_update}\footnote{\texttt{ltm/Date} corresponde a un mensaje ROS auxiliar definido en el paquete \texttt{ltm}, para representar una fecha mediante los campos: día, mes y año.}: Fecha de la última vez que el indicador fue actualizado.
	\item \texttt{ltm/Date next\_update}: Fecha de la próxima actualización agendada.
\end{itemize}

Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/HistoricalRelevance historical}: Se agrega una instancia del mensaje ROS de tipo \texttt{HistoricalRelevance.msg}, para almacenar la información relativa a la relevancia histórica del episodio.
\end{itemize}


\subsection{Datos para introspección}

% SOBRE RAZONAMIENTO
\paragraph{Metadatos:}
El último conjunto de datos considerado para almacenar junto a cada episodio es denominado \textit{Metadatos}. Éstos no están ligados a algún requerimiento de software, por lo que no son formalmente necesarios, sin embargo, permiten almacenar datos útiles para la implementación LTM, y sirven para conocer información sobre el software utilizado para almacenar cada episodio. Los \textit{Metadatos} tienen como finalidad ser de utilidad al resolver problemas relacionados al software LTM, y para cuando los usuarios deseen conocer el contexto de software sobre el cual fue generado el episodio.

% MENSAJE ROS
\paragraph{Representación:}
Para su diseño, se crea un mensaje de tipo \texttt{Info.msg} con los siguientes campos:
\begin{itemize}
%\texttt{int32 n\_usages}:     % e.g. 10
\item \texttt{string source}: Permite un nombre asociado a la fuente del episodio. Por ejemplo, ``smach'', ``json'' o ``dummy''.
\item \texttt{time creation\_date}: Sirve para indicar la fecha de creación del episodio, la que puede diferir del tiempo indicado en el campo \texttt{When}.
% \item \texttt{time last\_access}:  Sirve para indicar la fecha del último acceso al episodio.
\item \texttt{string ltm\_version}: Versión del sistema LTM utilizado. Por ejemplo, ``0.0.0''.
\item \texttt{string ros\_version}: Distribución de ROS utilizada. Por ejemplo, ``kinetic''.
\item \texttt{string os\_version}: Información sobre el sistema operativo donde se ejecuta el servidor LTM. Por ejemplo, ``GNU/Linux, Ubuntu 16.04, 4.13.0-43-generic, x86\_64''.
\end{itemize}
\todolater{Corregir campos con los de la versión final.}

Luego, se modifica el mensaje \texttt{Episode.msg} como sigue:
\begin{itemize}
	\item \texttt{ltm/Info info}: Se agrega una instancia del mensaje \texttt{Info.msg}, para almacenar los metadatos del episodio.
\end{itemize}


\subsection{Limitantes y trabajo futuro}

% SOBRE LIMITANTES DEL DISEÑO Y TRABAJO FUTURO

A continuación se presenta un conjunto de limitantes conocidas del diseño episódico desarrollado, las que pueden ser consideradas como parte del trabajo futuro del proyecto.

% SOBRE COMPLETITUD Y LAPSOS EN BLANCO..
\paragraph{Ausencia de hijos:} Este problema fue explicado parcialmente en la Sección \ref{sec:design_ep_when}, y aparece con padres cuyo rango temporal no es cubierto completamente por sus hijos. Cómo se verá en la Sección \ref{}, esto puede suceder cuando el usuario decide no almacenar algunos episodios hoja, pues los considera poco relevantes. El efecto de ésto, es que puede haber información no presente en los padres, al calcular sus datos a partir de sus hijos. Particularmente, esto sucede con la información para \textit{When}, \textit{What} y las relevancias episódicas. Se puede argumentar que, ya que el usuario considera que los subepisodios eran irrelevantes, entonces la información perdida también lo es. Sin embargo, por motivos de introspección, puede ser de interés almacenar los datos de \textit{streams} asociados a los periodos temporales perdidos.

\paragraph{Episodios de larga duración:}
A pesar de que el diseño del servidor permite episodios de duración indefinida, en la práctica, es raro que el robot funcione por periodos prolongados. Luego, los episodios cuyo fin es dar un contexto temporal a un árbol no pueden ser almacenados directamente (por ejemplo, cuando el robot está participando en una competencia de 4 días de duración). A pesar de lo anterior, el diseño permite la introducción manual de episodios de larga duración, sin tener que mantener en funcionamiento el robot durante todo el periodo.

\todoimplementation{COMO MANEJAR CONTEXTOS, PUES SE PUEDE REQUERIR SU INFORMACIÓN, INCLUSO DURANTE EL MISMO EPISODIO!!.. DEBEN SER ALMACENADOS UNA VEZ INSCRITOS Y SER CERRADOS MANUALMENTE.}


\todowrite{Limitante Where: En un futuro se podría agregar un 3er nivel de información, para almacenar info ultra específica, por ejemplo: ``al lado de la tele'', ``cerca del refrigerador''..}


% SOBRE UBICACIÓN
\todopaused{Depende de reimplementación del sistema de ubicación}

%       - ubicación 2D
%       - ubicación y frames
%       - ubicaciones de hojas con sólo un lugar... vs episodios con movimiento.
%       - padres mantienen con mismo frame y mapa de hijos


% ==============================================================================
% ==============================================================================
\section{Diseño del modelo de datos}
% ==============================================================================
% ==============================================================================
% - Diseño de Base de Datos:

Es esta sección se presentan las decisiones sobre el diseño de la base de datos a utilizar para el proyecto. En primer lugar, se revisan las consideraciones sobre la base de datos escogida: \textit{MongoDB}. Luego, se describe el manejo de mensajes episódicos y sus datos semánticos asociados, \textit{streams} y entidades.


\subsection{Base de datos}

% SOBRE SELECCIÓN DE MONGO DB
\paragraph{MongoDB:}
Según se explicó en la Sección \ref{}, la implementación del sistema LTM requiere el manejo de datos aleatorios, representados mediante mensajes de ROS que debe definir el usuario. Además, el sistema debe permitir modificar la representación de tales mensajes a futuro y soportar el almacenamiento de datos binarios. Por lo tanto, se requiere el uso de una base de datos no relacional, capaz de manejar cualquier mensaje definido en ROS. Para ésto, se decidió utilizar la base de datos no relacional \textit{MongoDB}, presentada en la Sección \ref{}. 

La decisión sobre el uso \textit{MongoDB} se basa en tres razonamientos principales. Primero, el driver ROS para ésta es considerado estable, al menos hasta el año 2023. \textit{MongoDB} es utilizado por la librería \textit{MoveIt} de ROS, de uso extendido en la comunidad, por lo que ya ha sido probada y está disponible en muchos robots de servicio domésticos. Finalmente, \textit{MongoDB} se ocupa actualmente en el robot Bender. Debido a lo anterior, esta elección minimiza problemas de dependencias y compatibilidad a futuro.

\todounsure{Es correcto hablar de drivers??.. debo hablar sobre controladores?..}


% SOBRE SEPARACIÓN DE COLECCIONES
\paragraph{Colecciones:}
Debido al funcionamiento del driver ROS para \textit{MongoDB}, se asociará una colección distinta para cada mensaje episódico de interés. Particularmente, una colección será destinada al almacenamiento del mensaje \texttt{Episode.msg}, mientras que cada mensaje definido por el usuario será  asociado a una colección distinta. En primera instancia, la base de datos no relacional permitiría almacenar todos los mensajes en la misma colección, pero la separación de cada tipo de dato en colecciones distintas es conveniente debido a lo siguiente. Primero, la separación permite optimizar consultas simples a la base de datos, que no requieran acceder a toda la memoria semántica asociada. Además, mediante la separación se evita propagar problemas al registro de episodios, cuando se presenten fallos en los controladores de memoria semántica que debe implementar el usuario. Finalmente, ya que el sistema debe soportar una cantidad indefinida de mensajes ROS elegidos por el usuario, se evita saturar el registro de episodios con mensajes que, una vez agrupados, superen el límite de tamaño permitido a cada elemento de una colección.

% REQUISITO DE MODIFICACIÓN DE REPRESENTACIÓN
% modificar msg de colección MD5 y poder seguir ocupando la base de datos.
% - mongo no tiene problema en modificar representación ...
% - el driver ROS si.
.
\todopaused{Describir cuando esté solucionado.}


\subsection{Colección de episodios}

Toda la información episódica, definida por medio del mensaje \texttt{Episode.msg}, será almacenada en la colección \texttt{episodes}.

Debido a los requisitos de software \hl{(RSXX) y (RSXX)}, cada episodio debe ser indexado por todos sus campos disponibles, propuestos en la Sección \ref{}. Sin embargo, por temas prácticos, no es posible indexar todos los datos asociados al campo \textit{What}. En el caso de entidades, queda a criterio del usuario. Mientras que en el caso de \textit{streams}, no tiene sentido indexar cada pixel de una imagen, o cada instante de sonido a almacenar.


% SOBRE CONSULTAS QUE DEBE SOPORTAR?
\todowrite{Sobre consultas episódicas que debe soportar el modelo.}


% MODIFICACIÓN DEL MENSAJE ROS
Una vez definido que los mensajes para \textit{streams} y entidades serán almacenados en colecciones propias, queda la definición del mensaje \texttt{What.msg}, encargado de almacenar las referencias a cada dato semántico relacionado al episodio. Para ello, se modifica el mensaje \texttt{Episode.msg}:
\begin{itemize}
	\item \texttt{ltm/What what}: Se agrega una instancia del mensaje \texttt{What.msg}. Sus contenidos son descritos en las siguientes secciones.
\end{itemize}



\subsection{Colecciones de streams}

Según se explicó anteriormente, cada \textit{stream} definido por el usuario es asociado a una colección de \textit{MongoDB} propia. El nombre de la colección debe ser definido por el usuario. 

Ya que los \textit{streams} se consideran datos con sólo una instancia por cada episodio, se decide utilizar el mismo identificador único para ambas estructuras. Así, el episodio identificado por el valor $A$, tendrá asociado un \textit{stream} de cada colección, cada uno con el identificador $A$.

\todoimplementation{Que el server avise si hay colecciones con nombres repetidos.}

Por lo general, los campos de un \textit{stream} no requieren ser indexados, ya que es conveniente almacenarlos como campos binarios. Sin embargo, durante la implementación del \textit{plugin} asociado, el usuario puede decidir añadir metadatos para indexar campos convenientes. La utilidad de ésto, es que permitirá agregar nuevos términos de comparación para las consultas a la base de datos. Luego, se tienen dos formas de acceder a un \textit{stream} en particular; mediante su mensaje episódico asociado, o a través de los metadatos definidos por el usuario.

Utilizando la configuración por defecto de \textit{MongoDB}, el límite de tamaño para cada mensaje ROS a almacenar es de $16 MB$, lo que impone una cota superior a la cantidad de datos que pueden ser almacenados por cada episodio. Por ejemplo, esto permitiría almacenar $N$ imágenes a color de tamaño $AxB$, o $M$ imágenes en escala de grises del mismo tamaño. Sin embargo, \textit{MongoDB} provee estrategias de almacenamiento que no consideran esa limitante, las que deben ser configuradas por el usuario.
\todowrite{Corregir comparación de 16MB con cantidad de imágenes. Ojo con formato y serialización.}
\todoimplementation{Server con warning si mensaje a almacenar pesa más del límite!.}

% - cambio de representación (MD5)
\todopaused{Sobre la modificación de la estructura del stream... MD5...}



% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
Considerando lo anterior, se modifica el mensaje \texttt{What.msg} para agregar referencias a los \textit{streams} almacenados.
\begin{itemize}
	\item \texttt{string[] streams}: Listado de \textit{streams} almacenados para el episodio,  referenciados por los nombres de sus colecciones. El identificador del \textit{stream} corresponde al campo \texttt{uid} del episodio.
\end{itemize}

\todoimplementation{Se podría agregar ID opcional del stream. Si ID=0, entonces se ocupa el uid del episodio. Sirve para casos de prueba en donde se busque crear N episodios, pero no se requiera crear N streams de cada tipo. i.e., para asociar ID fijo a todo un set de episodios.}

\subsection{Colecciones de entidades}

Cada mensaje ROS definido por el usuario, para representar una entidad de la memoria semántica, es  asociado a una colección de \textit{MongoDB} propia. El nombre de ésta debe ser definido por el usuario. 

A diferencia de los \textit{streams}, cada episodio puede estar asociado a una o más instancias de una entidad semántica. Por ejemplo, dada una entidad ``Persona'', durante un mismo episodio se pueden obtener datos (e.g., fecha de última visualización) para las instancias ``Jonh'' y ``Mike'', los que son almacenados en la misma colección, pero en distintas entradas.

\todoimplementation{Escribir cuando esté implementado correctamente.}

\todopaused{Sobre modelo de datos y flexibilidad...}
\todopaused{Sobre modelo de datos y perspectiva...}
% - cómo cumplir reglas sobre flexibilidad y perspectiva. Audit trail.

% SOBRE CONSULTAS QUE DEBE SOPORTAR?
\todowrite{Sobre consultas episódicas que debe soportar el modelo.}
\todopaused{Sobre metadatos}
\todopaused{Sobre tags definidos en campo What.}

% - cambio de representación (MD5)
\todopaused{Sobre la modificación de la estructura de entidades... MD5...}

% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
% TODO


\subsection{Limitantes y trabajo futuro}
% - otras funcionalidades de interés: bkp, migrate a otro robot, ...

% - metadatos de arreglos... por el driver ROS...

% - cosa MD5

.


% ==============================================================================
% ==============================================================================
\section{Diseño del servidor LTM}
% ==============================================================================
% ==============================================================================
%    - TODO: manejo de contexto
 .
 
% revisar requerimientos software asociados.

\subsection{Manejo de episodios}
% - Diseño del servidor LTM según requisitos
% - uso de MongoDB
% - Minimizar dependencias
% - API ROS: servicios, parámetros, nodos
% - parámetros (dar énfasis en la implementación)
% - estrategia de actualización episódica... branching.. etc.
.

\subsection{Sistema de plugins}
% - Sistema de plugins para agregar cosas específicas a cada robot
%    - where, emociones, streams y entidades.

%    - sobre información disponible para cada plugin
%    - requerimientos para cada plugin
%    - uso esperado de pluginlib
%    - flujo de trabajo de cada plugin
%    - se recomienda que sólo estén en funcionamiento cuando hay episodios registrados pendientes.
%    - sobre estabilidad de plugins.
.

\subsection{Alcances y trabajo futuro}
%    - Alcances y trabajo futuro
%        - reservar ids mientras nodo esté activo.
%        - posibles funcionalidades de interés: 
%           - visualizador
%           - 
 .


% ==============================================================================
% ==============================================================================
\section{Diseño de módulos específicos para Bender}
% ==============================================================================
% ==============================================================================

Según especifica el requisito de software \hl{(RSXX)}, el proyecto debe ser integrado al robot Bender, con una demostración de las capacidades del sistema LTM. Para esto, se deben implementar módulos de software que permitan recolectar todos los datos episódicos requeridos por el servidor. A continuación se describe el diseño de los componentes a implementar: la interfaz para recolectar episodios, la posición del robot y sus emociones, junto a los plugins para la recolección de streams y entidades a partir de la memoria de trabajo. 

Cada uno de los módulos presentados a continuación cumple una doble funcionalidad. En primer lugar, cumplen con el requisito del diseño de componentes orientados a robots de servicio doméstico, enfocados en el robot Bender. Y además, sirven como ejemplo para el diseño e implementación de nuevas funcionalidades requeridas a futuro para otras plataformas.


\subsection{Recolección de episodios: SMACH}

\paragraph{SMACH:}
El módulo específico más importante a implementar corresponde al encargado de generar episodios a partir del funcionamiento del robot, para luego entregarlos al servidor LTM. Como se explica en la Sección \ref{}, en Bender se utiliza la librería SMACH para la definición y ejecución de las máquinas de estado encargadas de encadenar rutinas simples, para generar comportamientos complejos. A través de SMACH, en Bender se implementan capacidades como la interacción continuada con humanos y la resolución de tareas en el hogar. 

\paragraph{Información episódica:}
A partir de SMACH se puede obtener parte del conocimiento episódico requerido para la definición de un episodio. Desde el punto de vista de sus transiciones, las máquinas de estado están estructuradas en forma de grafo, estableciendo un inicio y fin temporal para cada estado. Conceptualmente, las máquinas se estructuran en forma de árboles, donde cada maquina de estado puede ser contenida por otra, lo que representa el anidamiento episódico. Luego, SMACH provee una forma de conocimiento episódico, capaz de representar información temporal (\textit{When}) y las relaciones de anidamiento episódico (referencias padre-hijo). Finalmente, ya que cada máquina de estado está asociada a una capacidad o contexto, se puede utilizar esa información para obtener los \textit{tags} requeridos para marcar cada episodio.

\paragraph{Funcionamiento:}
La interfaz episódica diseñada tiene 2 etapas importantes. En primer lugar, el durante la programación de la máquina, el desarrollador debe indicar que estados considera almacenar como episodio, en caso que sean ejecutados. Además, se deben para cada estado marcado, se debe indicar una lista de \textit{tags} que describan brevemente el estado. La segunda etapa ocurre durante el funcionamiento de la máquina de estado; Al inicio de cada estado, la interfaz debe registrar el episodio en el servidor e indicar el identificador de su estado padre, para recibir el identificador generado para tal estado. Al fin de cada episodio, debe notificar el cierre al servidor, para que éste ejecute las rutinas de recopilación de datos y almacene el episodio.


\paragraph{Estabilidad de la implementación:}
La ejecución ininterrumpida de SMACH durante una rutina crucial para el desempeño del robot. Si la librería deja de funcionar repentinamente o se detiene continuamente, el robot se detendrá o tomará mucho tiempo en realizar sus tareas, lo que durante una competencia puede tener pésimas consecuencias para el equipo. Es por esto, que la implementación de la interfaz entre el servidor LTM y SMACH debe ser estable. Particularmente, es de vital importancia que el funcionamiento de SMACH no se vea afectado por la implementación, independientemente de si ésta tiene problemas en su ejecución. 


\paragraph{Intrusividad:}
Por otro lado, la implementación debe minimizar las modificaciones a la librería SMACH y a las máquinas de estado ya implementadas. En primer lugar, si se modifica la librería SMACH, el equipo tendrá que agregar una copia de ésta y mantenerla a futuro, para lo que no hay personal ni tiempo suficiente. Segundo, el robot dispone de muchas máquinas de estado, las que deberán ser actualizadas para agregar la funcionalidad de la interfaz episódica. Por lo tanto, se toman las siguientes decisiones:
\begin{itemize}
\item La librería SMACH no puede ser modificada para la implementación de la interfaz.
\item Las modificaciones a las máquinas de estado deben ser mínimas y opcionales. Esto permitirá ir agregando soporte LTM de manera gradual al robot.
\end{itemize}



\subsection{Recolección de dato episódico: \textit{Where}}

% SOBRE plugin
Según el diseño del servidor LTM, la información episódica \textit{Where} debe ser obtenida a través de un plugin especializado para ello. Entonces, se debe implementar un plugin para Bender, capaz de proveer la posición del robot durante un periodo de tiempo, según los requerimientos especificados en la Sección \ref{}.

% SOBRE: Funcionamiento del plugin
% - recopilación constante de posicionamiento del robot.
% - provee listado de poses dado tiempos de inicio, fin de episodio.
% - sólo recopila información cuando hay episodios registrados.

% SOBRE: Plugin con información Dummy
% - motivación... sirve para simulación, sin requerir que el robot funcione realmente.
% - generación de posiciones aleatorias en un rango determinado.
% - provee lugares aleatorios.

% SOBRE: Interfaz con robot Bender.
\todoimplementation{Plugin Where en Bender.}



\subsection{Recolección de dato episódico: Emociones}

% SOBRE: plugin
% - sobre diseño del server asociado.
% - sobre lo que debe proveer el plugin.

% SOBRE: requerimientos del server
% - recopilación de emociones .. buffer
% - provee emoción más fuerte del periodo.
% - rellenar metadatos 
% - sólo recopilar info si hay episodios registrados.

% SOBRE: plugin dummy
% - motivación  ... robot no dispone de emociones! también deben ser implementadas. Sirve para testing.
% - generación de datos dummy

% SOBRE: Interfaz con robot Bender.
\todoimplementation{Plugin Where en Bender.}
.

\subsection{Plugin para streams: Imágenes}

% SOBRE: plugin


% - memoria de trabajo a memoria semántica
% - por qué elección del pluign... demostración y visualización.. la mejor descripción la da una imagen.

% SOBRE: requerimientos del server
% - sobre marcar inicio, fin
% - sobre definición de colección
% - sobre manejo de la colección: CRUD
% - sobre API ROS asociada.

% SOBRE: Funcionamiento
% - estrtategia de procesamiento
% - buffer
% - periodicidad
% - ... revisar implementación ...

% SOBRE: plugin dummy
% - motivación.. sirve para simulación y pruebas, sin tener acceso al robot.
% - generación de stream de imágenes a partir de un video

% SOBRE Plugin a partir de cámara de cabeza.. una o dos cámaras...
% - sobre eso, siguiendo estrategia definida.
% - otros de interés: sonido, pcl..

.

\subsection{Plugins para entidades}
.
\todopaused{Requiere implementación funcional de plugin para entidades.}

% SOBRE: plugin
% - % memoria de trabajo a memoria semántica
% - por qué elección del pluign.. entidades importantes para robots de servicio domésticos.
% - % - Entidades: People, Objects, Robot, Location

% SOBRE: requerimientos del server
% - sobre marcar inicio, fin
% - sobre definición de colecciones
% - sobre manejo de la colección: CRUD
% - sobre API ROS asociada.

% SOBRE: Funcionamiento
% - estrtategia de procesamiento
% - buffer
% - periodicidad
% - ... revisar implementación ...

% SOBRE: plugin dummy
% - motivación.. sirve para simulación y pruebas, sin tener acceso al robot.
% - generación de stream de imágenes a partir de un video

% SOBRE Plugin a partir de cámara de cabeza.. una o dos cámaras...
% - sobre eso, siguiendo estrategia definida.













