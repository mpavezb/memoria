\chapter{Implementación}\label{chapter:implementacion}

\todo[inline]{======================================================\\
======================================================\\
================== ESCRIBIENDO - NO REVISAR ================\\
======================================================\\
======================================================\\
}

\todounsure{convex hull}
\todounsure{procesamiento de imágenes: degradación de streams}
\todounsure{Algs utilizados para emociones implementadas en robot}
\todounsure{Sistemas de coordenadas?? Frames?}


Es éste capítulo se describe la implementación del proyecto, a partir de las decisiones de diseño expuestas en el Capítulo \ref{chapter:diseno}. Primero, se presenta la estructuración del software en términos de archivos y paquetes ROS. Luego se muestran los mensajes episódicos sobre los que se construye el proyecto. En tercer lugar, se presentan módulos de software desarrollados para acelerar la implementación y validación del proyecto. Luego, se presenta la implementación del servidor LTM, junto a los módulos encargados de generar información episódica ficticia y los encargados de recolectar datos desde el robot. Finalmente, se muestra la integración del sistema en Bender.

% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Estructura del software e instalación}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

Esta sección presenta la estructuración del software implementado, en términos de sus archivos y paquetes ROS involucrados. Se describen las dependencias del proyecto, la estructura elegida para el servidor LTM, y la estructura para los plugins encargados de la recolección de información episódica.

\subsection{Dependencias}

A continuación se describen todas las dependencias de software utilizadas para la implementación del proyecto. Éstas se dividen en las siguientes categorías: de sistema, del lenguaje C++, del lenguaje Python y de ROS.

\todoimprove{Añadir versión de cada dependencia.}

\subsubsection{Sistema}

El proyecto fue desarrollado en Linux, Ubuntu 16.04, utilizando la distribución \textit{kinetic} de ROS, la que cuenta con soporte hasta Abril del año 2021. A pesar de lo anterior, el sistema debería ser compatible con versiones más recientes de ROS y Ubuntu, siempre que existan las dependencias mostradas en las siguientes secciones. A continuación se muestra el listado de paquetes extra, requeridos para el funcionamiento del proyecto.

\begin{itemize}
\item {\bfseries mongodb-server}: Paquete de software que contiene el servidor de MongoDB para Ubuntu 16.04.
\end{itemize}


\subsubsection{Dependencias C++}

El servidor fue implementado completamente utilizando C++, bajo el estándar C++03, que es soportado por la mayoría de los compiladores actuales y es el utilizado por defecto en ROS kinetic. A continuación se listan las dependencias de C++ utilizadas para la implementación del servidor.

\begin{itemize}
	\item {\bfseries mongo-cxx-driver}: Driver oficial para mongodb en C++. Más información en su repositorio oficial: \url{https://github.com/mongodb/mongo-cxx-driver.git}. 
	\item {\bfseries Boost Geometry}: Utilizado para el cómputo de la envoltura convexa y para el cálculo del centroide de un polígono.
\end{itemize}


\subsubsection{Dependencias Python}

Se utiliza Python en su versión 2.7, que es el estándar utilizado para ROS kinetic. Ya que el servidor está completamente implementado en C++, las siguientes dependencias son sólo para los módulos específicos para la integración con Bender o para el software demostrativo.

\begin{itemize}
\item {\bfseries cv2}: Librería OpenCV 2. Utilizada para insertar imágenes ficticias en entidades. 
\item {\bfseries faker}: Librería utilizada para la generación de datos ficticios para entidades. Más información en su web oficial: \url{https://github.com/joke2k/faker}.
\end{itemize}

\todoimplementation{Mover JSON loader fuera del package principal?}

\subsubsection{Dependencias ROS}

A continuación se listan las dependencias de paquetes ROS utilizados para la implementación del servidor.
\begin{itemize}
	\item Suite estándar de mensajes y servicios: std\_srvs, std\_msgs, geometry\_msgs, sensor\_msgs.
	\item {\bfseries pluginlib}: Librería estándar para la implementación de plugins en ROS.
	\item {\bfseries warehouse\_ros\_mongo}: Interfaz ROS para el almacenamiento de mensajes en MongoDB. Es una librería estándar, pero por errores al actualizar versiones de ROS, el paquete aún no está disponible en el canal oficial para ROS kinetic. Más información en el repositorio oficial: \url{https://github.com/ros-planning/warehouse\_ros\_mongo}.
\end{itemize}

Las siguientes dependencias extra, son paquetes ROS utilizados para la implementación de componentes específicas para el robot Bender y para el software demostrativo.
\begin{itemize}
\item {\bfseries smach, smach\_ros}: Librería SMACH. Utilizada para la implementación de la interfaz episódica con máquinas de estado.
\item {\bfseries cv\_bridge}: Interfaz ROS con librería OpenCV. Utilizado para el manejo de imágenes en los plugins.
\end{itemize}
\todopaused{Actualizar dependencias tras integración.}


\subsection{Paquetes de software desarrollados}\label{sec:impl_packages}

Con el motivo de separar conceptos e implementar un software independiente del robot objetivo, se desarrollaron 5 paquetes ROS. Uno de ellos contiene solamente la implementación del servidor, otro provee plugins e interfaces episódicas genéricas, otro contiene código de ejemplo, para pruebas y validación. Los dos últimos contienen implementaciones específicas para el robot Bender.

Todos los paquetes de ROS implementados cuentan con un repositorio de software en GitHub, de carácter público.

\subsubsection{Paquete ROS: \texttt{ltm}}

Contiene solamente la implementación del servidor y la documentación de éste. No se incluyen plugins ni interfaces episódicas, pues son consideradas como software no necesario o muy específico para un robot, como para ser considerado genérico. El paquete se puede encontrar en el siguiente repositorio público de software: \url{https://github.com/mpavezb/ltm}.

\subsubsection{Paquete ROS: \texttt{ltm\_addons}}

Este paquete ROS implementa el plugin para adquisición de imágenes y las interfaces episódicas para JSON y SMACH. Contiene software genérico, agnóstico del robot a utilizar. Los tres componentes anteriores pueden ser considerados herramientas útiles para algún robot, pero que no son estrictamente necesarios para el funcionamiento del servidor LTM. El repositorio asociado se puede encontrar en: \url{https://github.com/mpavezb/ltm\_addons}.

\subsubsection{Paquete ROS: \texttt{ltm\_samples}}

Este paquete contiene implementaciones de ejemplo de algunos plugins episódicos, capaces de generar información ficticia. Además, el paquete contiene software útil para pruebas del funcionamiento del servidor y código para su validación. Su repositorio de software se encuentra en: \url{https://github.com/mpavezb/ltm\_samples}.

\subsubsection{Paquete ROS: \texttt{bender\_emotion}}

Ya que Bender no dispone de un software generador de emociones, este paquete implementa el sistema descrito en la Sección \ref{}. El repositorio se encuentra alojado en la cuenta GitHub del equipo encargado de Bender: \url{https://github.com/uchile-robotics/bender\_emotion}.

\subsubsection{Paquete ROS: \texttt{bender\_ltm}}

Este paquete implementa plugins específicos para el uso del sistema LTM en el robot Bender, y es considerado el punto de integración del proyecto con el robot. Similarmente al paquete \texttt{bender\_emotion}, su repositorio se encuentra alojado en: \url{https://github.com/uchile-robotics/bender\_ltm}.




\subsection{Detalles del software}

\todowrite{Incluir figura con diagrama de funcionamiento del server - robot.}

\todowrite{Ver en que puntos se pueden agregar diagramas y figuras explicativas.}

\todowrite{Incluir tabla con Líneas de código por lenguaje... ver memoria de IAN. Usar comando: \$ cloc ltm ltm\_samples}


\subsection{Documentación}

El software desarrollado para el servidor (paquete \texttt{ltm}), junto a los plugins de ejemplo para recopilación de información ficticia (paquete \texttt{ltm\_samples}), y las interfaz episódica en SMACH (paquete \texttt{ltm\_addons}), se encuentra documentado en el archivo \texttt{README.md} del repositorio de software `ltm`, disponible en  \url{https://github.com/mpavezb/ltm}.

La documentación incluye una guía de instalación del proyecto y sus dependencias, junto a un tutorial sobre el uso del servidor y la elaboración de plugins.

\todoimplementation{Completar tutoriales o quitarlos del informe.}


% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Mensajes episódicos}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

En ésta sección se muestran los mensajes ROS implementados para manejar el concepto de episodios, los que son la base sobre la que se construye el sistema LTM y definen la estructura episódica a utilizar para la comunicación entre los clientes y el servidor en ROS.

\todounsure{Pongo código fuente de todos los mensajes definidos?.. los pongo en los anexos?.. son 3 páginas de sólo código!!}


% \ref{lst:episode.msg}
\subsection{Mensajes definidos por el servidor}

\paragraph{Representación:}
Luego, se construye un nuevo mensaje de ROS, \texttt{Episode.msg}, al cual se le agregan los siguientes campos:
\begin{itemize}
	\item Campo \texttt{uint32 uid}: Sirve para indicar el identificador único asignado al episodio.
	\item Campo \texttt{string[] tags}: Vector de tags, para almacenar todos los \textit{tags} asociados al episodio.
\end{itemize}

% SOBRE EL MSG ROS
\paragraph{Representación:}
Finalmente, tomando en cuanta las consideraciones anteriores, se agregan los ajustes siguientes al mensaje de ROS:
\begin{itemize}
	\item Campo \texttt{uint32 parent\_id}: Sirve para indicar el campo \texttt{uid} del padre del episodio. Se reserva el valor $0$ de éste campo para representar el padre de un episodio raíz.
	\item Campo \texttt{uint32[] children\_ids}: Vector de \texttt{uid} asociadas a los episodios hijos. No existe condición sobre el orden temporal de los episodios hijos.
	\item Campo \texttt{uint8 type}: Sirve para indicar si el episodio debe ser considerado como hoja o nodo del árbol.
	\item Campo \texttt{string[] children\_tags}: Vector que sirve para acceder rápidamente a todos los \texttt{tags} definidos en los hijos. Se reserva el campo \texttt{tags}, para dar descripciones asociadas solamente al episodio actual.
\end{itemize}
\todoimplementation{Optimización: condición de que hijos son ordenados por tiempo de inicio}

% SOBRE EL MENSAJE ROS
\paragraph{Representación:}
Entonces, se crea el mensaje \texttt{When.msg} para almacenar el contexto temporal del episodio, con los siguientes campos:
\begin{itemize}
	\item \texttt{time start}\footnote{El tipo de dato \texttt{time} es estándar en ROS y permite indicar un instante de tiempo mediante un contador de segundos transcurridos desde el tiempo cero (Jueves 1 de Enero de 1970 a las 00:00:00). Tiene una resolución de nanosegundos.}: Indica el instante en que se inicia el episodio.
	\item \texttt{time end}: Indica el instante en que finaliza el episodio.
\end{itemize}

Y el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/When when}\footnote{El dominio \texttt{ltm/} hace referencia al nombre del paquete ROS donde se implementa el servidor y que contiene la definición de todos los mensajes relacionados.}: Se agrega una instancia del mensaje \texttt{When.msg}, para manejar el contexto temporal del episodio.
\end{itemize}


% SOBRE MENSAJE EPISODICO
\paragraph{Representación:}
Considerando el diseño estudiado, se crea el mensaje \texttt{Where.msg} para almacenar el contexto espacial del episodio, utilizando los siguientes campos:
\todopaused{Actualizar estos datos de acuerdo a la modificación que se hará al sistema.}
\begin{itemize}
	\item \texttt{geometry\_msgs/Point position}\footnote{El paquete de ROS \texttt{geometry\_msgs} proporciona mensajes para manejar primitivas geométricas y sus transformaciones. Pertenece al conjunto de paquetes para mensajes \texttt{common\_msgs}, el cual se considera estable. Más información en la web oficial: \url{http://wiki.ros.org/geometry\_msgs}}: Mensaje que permite definir la posición del robot durante la ocurrencia del episodio. A pesar de que el tipo de dato permite definir 3 coordenadas, sólo se consideran los campos \texttt{position.x} y \texttt{position.y}. En el caso de ser un nodo del árbol, corresponde al centroide del campo \texttt{children\_hull}.
	\item \texttt{string frame\_id}: Indica el nombre del sistema de coordenadas sobre el cual se define el campo \texttt{position}.
	\item \texttt{string map\_name}: Indica el nombre del mapa utilizado, en el cual se ubican la posición descrita y el sistema de coordenadas elegido. 
	\item \texttt{string location}: Nombre del lugar donde se encontraba el robot al momento del episodio.
	\item \texttt{string area}: Nombre del área en donde se ubica el lugar descrito por \texttt{location}. 
	\item \texttt{geometry\_msgs/Point[] children\_hull}:
	\item \texttt{string[] children\_locations}:
	\item \texttt{string[] children\_areas}:
\end{itemize}
\todoimplementation{Crear submensaje para Where.msg, que almacene: location, area, time}
\todoimplementation{Soportar más de 1 lugar semántico y coordenado para hijos.}
\todoimplementation{Modificar implementación para agregar soporte a más de un frame/mapa.}
\todoimplementation{Crear submensaje para Where.msg, que represente ubicación coordenada múltiple}
\todoimplementation{Limitantes Where: + de una posición.... Frames únicos por árbol}

Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/Where where}: Se agrega una instancia del mensaje \texttt{Where.msg}, para manejar el contexto espacial del episodio.
\end{itemize}

% MSG ROS
\paragraph{Representación:}
Luego, se crea un mensaje de tipo \texttt{Relevance.msg}, para almacenar las sub-relevancias del episodio y la relevancia generalizada. El mensaje es creado como sigue:
\begin{itemize}
	\item TODO
\end{itemize}
\todopaused{Agregar representación de relevancia generalizada, una vez que sea implementada.}


Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/Relevance relevance}: Se agrega una instancia del mensaje \texttt{Relevance.msg}, para almacenar toda la información relacionada a los indicadores de relevancia del episodio.
\end{itemize}

% MSG ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{EmotionalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{int32 emotion}: Valor que hace referencia a una de las 8 emociones base. En el caso de episodios nodo, hace referencia a la emoción con mayor relevancia.
	\item \texttt{float32 value}: Intensidad de la emoción seleccionada. Válido para episodios nodo y hojas.
	\item \texttt{int32[] children\_emotions}: Vector con identificadores de las 8 emociones base. Sólo es utilizado por episodios nodo.
	\item \texttt{float32[] children\_values}: Vector con intensidades de cada una de las 8 emociones base. Sólo es utilizado por episodios nodo.
	\item \texttt{string software}: Metadato. Nombre del sistema emocional utilizado.
	\item \texttt{string software\_version}: Metadato. Versión del sistema emocional utilizado.
	\item \texttt{string[] registered\_emotions}: Metadato. Descripción de emociones encontradas por el software generador de emociones. 
	\item \texttt{float32[] registered\_values}: Metadato. Intensidades de emociones descritas en el campo \texttt{registered\_emotions}.
\end{itemize}
\todoimplementation{8 emociones son requeridas!}

Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/EmotionalRelevance emotional}: Se agrega una instancia del mensaje ROS de tipo \texttt{EmotionalRelevance.msg}, para almacenar la información emocional relativa al episodio.
\end{itemize}


% MENSAJE ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{HistoricalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{float32 value}: Indicador numérico de la relevancia histórica del episodio.
	\item \texttt{ltm/Date last\_update}\footnote{\texttt{ltm/Date} corresponde a un mensaje ROS auxiliar definido en el paquete \texttt{ltm}, para representar una fecha mediante los campos: día, mes y año.}: Fecha de la última vez que el indicador fue actualizado.
	\item \texttt{ltm/Date next\_update}: Fecha de la próxima actualización agendada.
\end{itemize}

Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/HistoricalRelevance historical}: Se agrega una instancia del mensaje ROS de tipo \texttt{HistoricalRelevance.msg}, para almacenar la información relativa a la relevancia histórica del episodio.
\end{itemize}
\todopaused{Sobre la tasa de decaimiento histórica implementada.}

% MENSAJE ROS
\paragraph{Representación:}
Para su diseño, se crea un mensaje de tipo \texttt{Info.msg} con los siguientes campos:
\begin{itemize}
	%\texttt{int32 n\_usages}:     % e.g. 10
	\item \texttt{string source}: Permite un nombre asociado a la fuente del episodio. Por ejemplo, ``smach'', ``json'' o ``dummy''.
	\item \texttt{time creation\_date}: Sirve para indicar la fecha de creación del episodio, la que puede diferir del tiempo indicado en el campo \texttt{When}.
	% \item \texttt{time last\_access}:  Sirve para indicar la fecha del último acceso al episodio.
	\item \texttt{string ltm\_version}: Versión del sistema LTM utilizado. Por ejemplo, ``0.0.0''.
	\item \texttt{string ros\_version}: Distribución de ROS utilizada. Por ejemplo, ``kinetic''.
	\item \texttt{string os\_version}: Información sobre el sistema operativo donde se ejecuta el servidor LTM. Por ejemplo, ``GNU/Linux, Ubuntu 16.04, 4.13.0-43-generic, x86\_64''.
\end{itemize}
\todolater{Corregir campos con los de la versión final.}

Luego, se modifica el mensaje \texttt{Episode.msg} como sigue:
\begin{itemize}
	\item \texttt{ltm/Info info}: Se agrega una instancia del mensaje \texttt{Info.msg}, para almacenar los metadatos del episodio.
\end{itemize}

% MODIFICACIÓN DEL MENSAJE ROS
Una vez definido que los mensajes para \textit{streams} y entidades serán almacenados en colecciones propias, queda la definición del mensaje \texttt{What.msg}, encargado de almacenar las referencias a cada dato semántico relacionado al episodio. Para ello, se modifica el mensaje \texttt{Episode.msg}:
\begin{itemize}
	\item \texttt{ltm/What what}: Se agrega una instancia del mensaje \texttt{What.msg}. Sus contenidos son descritos en las siguientes secciones.
\end{itemize}
\todoimplementation{Mensajes definidos por usuario deben poseer un campo con metadatos, manejados por el server.}
\todoimplementation{LTM server con warning en texto y notificación inotify cuando quede poco espacio de disco (menor a X\%) (o se ha ocupado más de X GB) debido al server... configurable por usuario...}

% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
Considerando lo anterior, se modifica el mensaje \texttt{What.msg} para agregar referencias a los \textit{streams} almacenados.
\begin{itemize}
	\item \texttt{string[] streams}: Listado de \textit{streams} almacenados para el episodio,  referenciados por los nombres de sus colecciones. El identificador del \textit{stream} corresponde al campo \texttt{uid} del episodio.
\end{itemize}
\todoimplementation{Mensajes definidos por usuario deben poseer un campo con metadatos, manejados por el server.}

\todoimplementation{Se podría agregar ID opcional del stream. Si ID=0, entonces se ocupa el uid del episodio. Sirve para casos de prueba en donde se busque crear N episodios, pero no se requiera crear N streams de cada tipo. i.e., para asociar ID fijo a todo un set de episodios.}

% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
% TODO

\todoimplementation{COMO MANEJAR CONTEXTOS, PUES SE PUEDE REQUERIR SU INFORMACIÓN, INCLUSO DURANTE EL MISMO EPISODIO!!.. DEBEN SER ALMACENADOS UNA VEZ INSCRITOS Y SER CERRADOS MANUALMENTE.}


\todoimplementation{Modificación de la estructura de mensajes semánticos}
% modificar msg de colección MD5 y poder seguir ocupando la base de datos.
% - mongo no tiene problema en modificar representación ...
% - el driver ROS si.

\todoimplementation{Server con warning si mensaje a almacenar pesa más del límite!.}
\todowrite{Es labor del usuario definir el merge del historial.}

\todoimplementation{Condiciones de búsqueda para cada tipo de dato primitivo en ROS.}
\todoimplementation{Quitar Update service para episodios,streams y entidades.}

\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm/Episode.msg,label=lst:episode.msg]{code/msg/Episode.msg}

\subsection{Mensajes definidos por los plugins para Bender}

\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm\_samples/ImageStream.msg]{code/msg/ImageStream.msg}
\lstinputlisting[caption=ltm\_samples/PersonEntity.msg]{code/msg/PersonEntity.msg}
\lstinputlisting[caption=ltm\_samples/ObjectEntity.msg]{code/msg/ObjectEntity.msg}

% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Herramientas para validación}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

\subsection{Episodios JSON}
% - Episodios JSON: comprensión de la estructura a utilizar
.

\subsection{Episodios SMACH}
% - Episodios Smach: cubrir todos los casos de borde
.

\subsection{Robot ficticio}
% generar datos para plugins

% - Robot simulado: emociones y localización fakes

% - Streams Fake: videos.. proveer misma interfaz que el robot

% - Entidades Fake: Generador de campos para mensajes ... no existe interfaz en el robot para esto.

.

% ==============================================================================
% ==============================================================================\\
% ==============================================================================
% ==============================================================================
\section{Servidor LTM}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.
% OVERVIEW
% uso de diseño explicado en la sección X
% implementación completa en C++
% sobre el manejo de la BD episódica utilizando el driver X

% MANEJO DE PLUGINS
% ==============================================================================
% ==============================================================================
\subsection{API pluginlib}
% ==============================================================================
% ==============================================================================

.
\subsubsection{Plugin: \textit{Where}}
% - API
% - convex hull

.
\subsubsection{Plugin: Emociones}
% - API

.
\subsubsection{Plugin: Streams}
% - API
% - Manejo de coleccion

.
\subsubsection{Plugin: Entidades}
% - Manejo de colecciones
% - API

.

% ==============================================================================
% ==============================================================================
\subsection{API ROS}
% ==============================================================================
% ==============================================================================
% API ROS:
% - Disponible a través de C++, Python, Java, Lisp, otros.

.

\subsubsection{Servicios implementados}
% - srv implementados
% - Servicios que provee



\subsubsection{Consultas episódicas}
% - consultas episódicas

.

\subsubsection{Configuración mediante ROS}

.
\lstset{style=/Style/yaml/ROS}
\lstinputlisting[caption=server.yaml]{code/config/server.yaml}
\todounsure{Listing en los anexos??}

\subsubsection{Launchfiles}



% ==============================================================================
% ==============================================================================
\subsection{Trabajo futuro}
% ==============================================================================
% ==============================================================================
% Trabajo Futuro

.



% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Módulos generadores de información ficticia}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de \textit{Where}}
% ==============================================================================
% ==============================================================================
% WHERE
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de emociones}
% ==============================================================================
% ==============================================================================
% EMOTIONS
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.



% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de imágenes}
% ==============================================================================
% ==============================================================================
% STREAMS EN VIDEO
% - buffer
% - configurable
% - Registro en pluginlib y configuración en el server

\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm\_samples/ImageStreamSrv.srv]{code/srv/ImageStreamSrv.srv}

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de entidades}
% ==============================================================================
% ==============================================================================
% ENTIDADES
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.



% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Módulos específicos para Bender}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.


% ==============================================================================
% ==============================================================================
\subsection{Interfaz con SMACH}
% ==============================================================================
% ==============================================================================
% INTERFAZ SMACH
% - SOBRE DISEÑO y PYTHON
% - implementación:
%   - registro de episodios y tags
%   - hooks para inicio y fin de episodios
%   - intrusividad: Implementación sin impacto en librería y que minimiza trabajo del equipo
%   - estabilidad: no morir ante nada!
% - test en todos los tipos de estado definidos?
% - ejemplo de funcionamiento
% - REVISAR MATCH CON DISEÑO ESCRITO

.



% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de \textit{Where}}
% ==============================================================================
% ==============================================================================
% INTERFAZ WHERE
% - API del ROBOT
% - buffer y periodicidad
% - selección de posiciones
% - registro y recolección
% - Registro en pluginlib y configuración en el server
% - REVISAR MATCH CON DISEÑO ESCRITO
.
\todopaused{Escribir cuando esté implementado}

\todowrite{PONERSE EN EL LUGAR DE NO ALCANZAR A IMPLEMENTAR EN BENDER... PERO DEJAR PROPUESTA...}


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de emociones}
% ==============================================================================
% ==============================================================================
% INTERFAZ EMOTIONS
% - API del ROBOT
% - buffer y periodicidad
% - selección de emocion
% - metadatos
% - registro y recolección
% - Registro en pluginlib y configuración en el server
% - REVISAR MATCH CON DISEÑO ESCRITO
% - Funcionalidades implementadas en el robot: 
%    - emociones simples.
%    - módulos disponibles (con el robot a medias)
.
\todopaused{Escribir cuando esté implementado}


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de imágenes}
% ==============================================================================
% ==============================================================================
% INTERFAZ IMAGES
% - API del ROBOT
.
\todopaused{Escribir cuando esté implementado}
\todoimplementation{Proveer plugin agnóstico al robot, configurable a través de parámetros.}

% ==============================================================================
% ==============================================================================
\subsection{Plugins para recolección de entidades}
% ==============================================================================
% ==============================================================================
% INTERFAZ ENTITIES
% - API del ROBOT
.
\todopaused{Escribir cuando esté implementado}


% ==============================================================================
% ==============================================================================\\
% ==============================================================================
% ==============================================================================
\section{Integración del sistema en Bender}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
% - instalación y convivencia con el software
% - visualización de datos episódicos.
% - Interfaz Robot: Emociones y Posición
% - Streams
% - Entidades

.
