\chapter{Implementación}\label{chapter:implementacion}

Es éste capítulo se describe la implementación del proyecto, a partir de las decisiones de diseño expuestas en el Capítulo \ref{chapter:diseno}. Primero, se presenta la estructuración del software en términos de archivos y paquetes ROS. Luego se muestran los mensajes episódicos sobre los que se construye el proyecto. En tercer lugar, se presentan módulos de software desarrollados para acelerar la implementación y validación del proyecto. Luego, se presenta la implementación del sistema LTM, junto a los módulos encargados de generar información episódica ficticia y los encargados de recolectar datos desde el robot. Finalmente, se muestra la integración del sistema en Bender.

\todowrite{Reescribir al final del cap.}
\todowrite{Agregar summary al final de cada cap.}

% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Estructura del software e instalación}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

Esta sección presenta la estructuración del software implementado, en términos de sus archivos y paquetes ROS involucrados. Se describen las dependencias del proyecto, la estructura elegida para el sistema LTM, y la estructura para los plugins encargados de la recolección de información episódica.

\subsection{Dependencias}

A continuación se describen todas las dependencias de software utilizadas para la implementación del proyecto. Éstas se dividen en las siguientes categorías: de sistema, del lenguaje \CC, del lenguaje Python y de ROS.


\subsubsection{Sistema}

El proyecto fue desarrollado en Linux, Ubuntu 16.04. Las dependencias del sistema LTM son las siguientes:

\begin{itemize}
\item {\bfseries ROS kinetic}: Se utilizó la distribución \textit{kinetic} de ROS, la que cuenta con soporte hasta Abril del año 2021.
\item {\bfseries mongodb-server}: Paquete de software que contiene el servidor de MongoDB para Ubuntu 16.04.
\end{itemize}

La implementación del sistema debería ser compatible con versiones más recientes de ROS y Ubuntu, siempre que estén disponibles las dependencias mostradas en las siguientes secciones.


\subsubsection{Dependencias C$++$}

El servidor fue implementado completamente utilizando \CC, bajo el estándar \CC03, que es soportado por la mayoría de los compiladores actuales y es el utilizado por defecto en ROS kinetic. A continuación se listan las dependencias de \CC \ utilizadas para la implementación del servidor.

\begin{itemize}
	\item {\bfseries mongo-cxx-driver}: Driver oficial para mongodb en \CC\footnote{Repositorio oficial de \texttt{mongo-cxx-driver}: \url{https://github.com/mongodb/mongo-cxx-driver.git}.}. 
	\item {\bfseries Boost Geometry}: Utilizado para el cómputo de la envoltura convexa y para el cálculo del centroide de un polígono.
\end{itemize}


\subsubsection{Dependencias Python}

Se utiliza Python en su versión 2.7, que es el estándar utilizado para ROS kinetic. Las siguientes dependencias son sólo para los módulos específicos para la integración con Bender o para el software demostrativo.

\begin{itemize}
\item {\bfseries cv2}: Librería OpenCV 2. Utilizada para insertar imágenes ficticias en entidades\footnote{Página oficial de OpenCV: \url{https://opencv.org/}}. 
\item {\bfseries faker}: Librería utilizada para la generación de datos ficticios para entidades\footnote{Repositorio oficial de librería \texttt{faker} para Python: \url{https://github.com/joke2k/faker}}.
\end{itemize}


\subsubsection{Dependencias ROS}

A continuación se listan las dependencias de paquetes ROS utilizados para la implementación del servidor.
\begin{itemize}
	\item Suite estándar de mensajes y servicios: std\_srvs, std\_msgs, geometry\_msgs, sensor\_msgs.
	\item {\bfseries pluginlib}: Librería estándar para la implementación de plugins en ROS.
\end{itemize}

Las siguientes dependencias son paquetes ROS utilizados para la implementación de componentes específicas para el robot Bender y para el software demostrativo.
\begin{itemize}
\item {\bfseries smach, smach\_ros}: Librería SMACH. Utilizada para la implementación de la interfaz episódica con máquinas de estado.
\item {\bfseries cv\_bridge}: Interfaz ROS con librería OpenCV. Utilizado para el manejo de imágenes en los plugins.
\end{itemize}


\subsection{Paquetes de software desarrollados}\label{sec:impl_packages}

Con el motivo de separar conceptos e implementar un software independiente del robot objetivo, se separó la implementación en 6 paquetes ROS. El primero provee la conexión a la base de datos. El siguiente contiene solamente la implementación del servidor, otro provee plugins e interfaces episódicas genéricas, otro contiene código de ejemplo, para pruebas y validación. Los dos últimos contienen implementaciones específicas para el robot Bender.

Todos los paquetes de ROS implementados cuentan con un repositorio de software en GitHub, de carácter público.

\subsubsection{Paquete ROS: \texttt{ltm\_db}}

El paquete se puede considerar un \textit{fork} de \texttt{warehouse\_ros\_mongo}. Extiende la versión original con nuevas funcionalidades, requeridas para la implementación del servidor LTM y el manejo de las colecciones en MongoDB.

Particularmente, se agregaron las siguientes funcionalidades:
\begin{itemize}
\item Soporte para agregar arreglos como campos para ser indexados en colecciones. Los arreglos se pueden construir para los siguientes tipos de datos en \CC: \texttt{std::string}, \texttt{int}, \texttt{double} y \texttt{bool}. 
\item Soporte para metadatos anidados.
\item Soporte para arreglos de objetos como metadatos de una colección.
\item Soporte para búsquedas de mensajes en colecciones, mediante condición de pertenencia de valor a un arreglo.
\item Soporte para consultas genéricas basadas en el sistema de consultas de MongoDB. Se puede realizar cualquier consulta y combinación de condiciones, expresable en formato JSON, utilizando el estándar de consultas de MongoDB.
\end{itemize}

El paquete ROS se puede encontrar en el siguiente repositorio público en GitHub: \url{https://github.com/mpavezb/ltm\_db}.

\subsubsection{Paquete ROS: \texttt{ltm}}

Contiene solamente la implementación del servidor y la documentación de éste. No se incluyen plugins ni interfaces episódicas, pues son consideradas como software no necesario o muy específico para un robot, como para ser considerado genérico. El paquete se puede encontrar en el siguiente repositorio público de software: \url{https://github.com/mpavezb/ltm}.

\subsubsection{Paquete ROS: \texttt{ltm\_addons}}

Este paquete ROS implementa el plugin para adquisición de imágenes y las interfaces episódicas para JSON y SMACH. Contiene software genérico, agnóstico del robot a utilizar. Los tres componentes anteriores pueden ser considerados herramientas útiles para algún robot, pero que no son estrictamente necesarios para el funcionamiento del sistema LTM. El repositorio asociado se puede encontrar en: \url{https://github.com/mpavezb/ltm\_addons}.

\subsubsection{Paquete ROS: \texttt{ltm\_samples}}

Este paquete contiene implementaciones de ejemplo de algunos plugins episódicos, capaces de generar información ficticia. Además, el paquete contiene software útil para pruebas del funcionamiento del sistema y código para su validación. Su repositorio de software se encuentra en: \url{https://github.com/mpavezb/ltm\_samples}.

\subsubsection{Paquete ROS: \texttt{bender\_emotion}}

Ya que Bender no dispone de un software generador de emociones, este paquete implementa el sistema emocional descrito en la Sección \ref{sec:design_bender}. El repositorio se encuentra alojado en la cuenta GitHub del equipo encargado de Bender: \url{https://github.com/uchile-robotics/bender\_emotion}.

\subsubsection{Paquete ROS: \texttt{bender\_ltm}}

Este paquete implementa plugins específicos para el uso del sistema LTM en el robot Bender, y es considerado el punto de integración del proyecto con el robot. Similarmente al paquete \texttt{bender\_emotion}, su repositorio se encuentra alojado en: \url{https://github.com/uchile-robotics/bender\_ltm}.


\subsection{Líneas de código}

En la Figura~\ref{table:lineas-codigo} se presenta una tabla con el conteo de líneas de código implementadas para el proyecto, ordenadas por el lenguaje utilizado. Se utilizó el programa \texttt{cloc}\footnote{Repositorio del programa \texttt{cloc} en GitHub: \url{https://github.com/AlDanial/cloc}} para realizar el cómputo.

\begin{figure}[!ht]
	\centering
	\begin{tabular}{|l|r|r|r|r|}
		\hline
		\rowcolor{gray!50}
		Lenguaje & Archivos & Líneas en blanco & Comentarios & Código \\ \hline
		C++                   &  32  &  669  &  422  &  3073 \\ \hline
		C/C++ Header          &  47  &  667  &  422  &  2192 \\ \hline
		Python                &  37  &  587  &  471  &  1812 \\ \hline
		JSON                  &  12  &    0  &    0  &   321 \\ \hline
		CMake                 &   5  &  107  &  219  &   312 \\ \hline
		XML                   &  17  &   91  &   79  &   213 \\ \hline
		Markdown              &   8  &   95  &    0  &   183 \\ \hline
		ROS msg/srv           &  30  &   34  &   72  &   177 \\ \hline
		BASH    &   2  &   21  &    7  &    99 \\ \hline
		YAML                  &   4  &   30  &   45  &    77 \\ \hline
		\rowcolor{gray!50}
		Total                 & 194  & 2301  & 1737  & 8459  \\ \hline	
	\end{tabular} 
	\caption{\small Líneas de código del sistema LTM por lenguaje.}
	\label{table:lineas-codigo}
\end{figure}


\subsection{Documentación}

Todos los paquetes ROS desarrollados para el sistema LTM, junto a los módulos de ejemplo para recopilación de información ficticia y desde el robot Bender, se encuentra documentado en el archivo \texttt{README.md} del repositorio de software \texttt{ltm}.

La documentación incluye una guía de instalación del proyecto y sus dependencias, junto a un tutorial sobre el uso del servidor y la elaboración de plugins.


% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Mensajes episódicos}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================


% IMPLEMENTACIÓN
% - Launchfiles
% - Configuración estática mediante Parameter Server
% - Plugins que fallan no son inicializados.
% - sobre estabilidad de plugins y daño al server.
% - Minimizar dependencias
%   - pluginlib, boost (operaciones geométricas, ...)

%    - Alcances y trabajo futuro
%        - reservar ids mientras nodo esté activo.
%        - posibles funcionalidades de interés: 
%           - visualizador
%           - 
% - uso esperado de pluginlib
% SOBRE MD5! Hay estrategia, pero aún no se incluye en la implementación. Por qué es importante?


\todounsure{convex hull}
\todounsure{procesamiento de imágenes: degradación de streams}
\todounsure{Algs utilizados para emociones implementadas en robot}
\todounsure{Sistemas de coordenadas?? Frames?}

En ésta sección se muestran los mensajes ROS implementados para manejar el concepto de episodios, los que son la base sobre la que se construye el sistema LTM y definen la estructura episódica a utilizar para la comunicación entre los clientes y el servidor en ROS.

% \ref{lst:episode.msg}
\subsection{Mensajes definidos por el servidor}

\paragraph{Representación:}
Luego, se construye un nuevo mensaje de ROS, \texttt{Episode.msg}, al cual se le agregan los siguientes campos:
\begin{itemize}
	\item Campo \texttt{uint32 uid}: Sirve para indicar el identificador único asignado al episodio.
	\item Campo \texttt{string[] tags}: Vector de tags, para almacenar todos los \textit{tags} asociados al episodio.
\end{itemize}

% SOBRE EL MSG ROS
\paragraph{Representación:}
Finalmente, tomando en cuanta las consideraciones anteriores, se agregan los ajustes siguientes al mensaje de ROS:
\begin{itemize}
	\item Campo \texttt{uint32 parent\_id}: Sirve para indicar el campo \texttt{uid} del padre del episodio. Se reserva el valor $0$ de éste campo para representar el padre de un episodio raíz.
	\item Campo \texttt{uint32[] children\_ids}: Vector de \texttt{uid} asociadas a los episodios hijos. No existe condición sobre el orden temporal de los episodios hijos.
	\item Campo \texttt{uint8 type}: Sirve para indicar si el episodio debe ser considerado como hoja o nodo del árbol.
	\item Campo \texttt{string[] children\_tags}: Vector que sirve para acceder rápidamente a todos los \texttt{tags} definidos en los hijos. Se reserva el campo \texttt{tags}, para dar descripciones asociadas solamente al episodio actual.
\end{itemize}

% SOBRE EL MENSAJE ROS
\paragraph{Representación:}
Entonces, se crea el mensaje \texttt{When.msg} para almacenar el contexto temporal del episodio, con los siguientes campos:
\begin{itemize}
	\item \texttt{time start}\footnote{El tipo de dato \texttt{time} es estándar en ROS y permite indicar un instante de tiempo mediante un contador de segundos transcurridos desde el tiempo cero (Jueves 1 de Enero de 1970 a las 00:00:00). Tiene una resolución de nanosegundos.}: Indica el instante en que se inicia el episodio.
	\item \texttt{time end}: Indica el instante en que finaliza el episodio.
\end{itemize}

Y el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/When when}\footnote{El dominio \texttt{ltm/} hace referencia al nombre del paquete ROS donde se implementa el servidor y que contiene la definición de todos los mensajes relacionados.}: Se agrega una instancia del mensaje \texttt{When.msg}, para manejar el contexto temporal del episodio.
\end{itemize}


% SOBRE MENSAJE EPISODICO
\paragraph{Representación:}
Considerando el diseño estudiado, se crea el mensaje \texttt{Where.msg} para almacenar el contexto espacial del episodio, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{geometry\_msgs/Point position}\footnote{El paquete de ROS \texttt{geometry\_msgs} proporciona mensajes para manejar primitivas geométricas y sus transformaciones. Pertenece al conjunto de paquetes para mensajes \texttt{common\_msgs}, el cual se considera estable. Más información en la web oficial: \url{http://wiki.ros.org/geometry\_msgs}}: Mensaje que permite definir la posición del robot durante la ocurrencia del episodio. A pesar de que el tipo de dato permite definir 3 coordenadas, sólo se consideran los campos \texttt{position.x} y \texttt{position.y}. En el caso de ser un nodo del árbol, corresponde al centroide del campo \texttt{children\_hull}.
	\item \texttt{string frame\_id}: Indica el nombre del sistema de coordenadas sobre el cual se define el campo \texttt{position}.
	\item \texttt{string map\_name}: Indica el nombre del mapa utilizado, en el cual se ubican la posición descrita y el sistema de coordenadas elegido. 
	\item \texttt{string location}: Nombre del lugar donde se encontraba el robot al momento del episodio.
	\item \texttt{string area}: Nombre del área en donde se ubica el lugar descrito por \texttt{location}. 
	\item \texttt{geometry\_msgs/Point[] children\_hull}:
	\item \texttt{string[] children\_locations}:
	\item \texttt{string[] children\_areas}:
\end{itemize}

Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/Where where}: Se agrega una instancia del mensaje \texttt{Where.msg}, para manejar el contexto espacial del episodio.
\end{itemize}

% MSG ROS
\paragraph{Representación:}
Luego, se crea un mensaje de tipo \texttt{Relevance.msg}, para almacenar las sub-relevancias del episodio y la relevancia generalizada. El mensaje es creado como sigue:
\begin{itemize}
	\item TODO
\end{itemize}
\todopaused{Agregar representación de relevancia generalizada, una vez que sea implementada.}


Finalmente, el mensaje \texttt{Episode.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/Relevance relevance}: Se agrega una instancia del mensaje \texttt{Relevance.msg}, para almacenar toda la información relacionada a los indicadores de relevancia del episodio.
\end{itemize}

% MSG ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{EmotionalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{int32 emotion}: Valor que hace referencia a una de las 8 emociones base. En el caso de episodios nodo, hace referencia a la emoción con mayor relevancia.
	\item \texttt{float32 value}: Intensidad de la emoción seleccionada. Válido para episodios nodo y hojas.
	\item \texttt{int32[] children\_emotions}: Vector con identificadores de las 8 emociones base. Sólo es utilizado por episodios nodo.
	\item \texttt{float32[] children\_values}: Vector con intensidades de cada una de las 8 emociones base. Sólo es utilizado por episodios nodo.
	\item \texttt{string software}: Metadato. Nombre del sistema emocional utilizado.
	\item \texttt{string software\_version}: Metadato. Versión del sistema emocional utilizado.
	\item \texttt{string[] registered\_emotions}: Metadato. Descripción de emociones encontradas por el software generador de emociones. 
	\item \texttt{float32[] registered\_values}: Metadato. Intensidades de emociones descritas en el campo \texttt{registered\_emotions}.
\end{itemize}
\todoimplementation{8 emociones son requeridas!}

Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/EmotionalRelevance emotional}: Se agrega una instancia del mensaje ROS de tipo \texttt{EmotionalRelevance.msg}, para almacenar la información emocional relativa al episodio.
\end{itemize}


% MENSAJE ROS
\paragraph{Representación:}
Considerando lo anterior, se crea el mensaje \texttt{HistoricalRelevance.msg}, utilizando los siguientes campos:
\begin{itemize}
	\item \texttt{float32 value}: Indicador numérico de la relevancia histórica del episodio.
	\item \texttt{ltm/Date last\_update}\footnote{\texttt{ltm/Date} corresponde a un mensaje ROS auxiliar definido en el paquete \texttt{ltm}, para representar una fecha mediante los campos: día, mes y año.}: Fecha de la última vez que el indicador fue actualizado.
	\item \texttt{ltm/Date next\_update}: Fecha de la próxima actualización agendada.
\end{itemize}

Finalmente, el mensaje \texttt{Relevance.msg} es modificado como sigue:
\begin{itemize}
	\item \texttt{ltm/HistoricalRelevance historical}: Se agrega una instancia del mensaje ROS de tipo \texttt{HistoricalRelevance.msg}, para almacenar la información relativa a la relevancia histórica del episodio.
\end{itemize}

% MENSAJE ROS
\paragraph{Representación:}
Para su diseño, se crea un mensaje de tipo \texttt{Info.msg} con los siguientes campos:
\begin{itemize}
	%\texttt{int32 n\_usages}:     % e.g. 10
	\item \texttt{string source}: Permite un nombre asociado a la fuente del episodio. Por ejemplo, ``smach'', ``json'' o ``dummy''.
	\item \texttt{time creation\_date}: Sirve para indicar la fecha de creación del episodio, la que puede diferir del tiempo indicado en el campo \texttt{When}.
	% \item \texttt{time last\_access}:  Sirve para indicar la fecha del último acceso al episodio.
	\item \texttt{string ltm\_version}: Versión del sistema LTM utilizado. Por ejemplo, ``0.0.0''.
	\item \texttt{string ros\_version}: Distribución de ROS utilizada. Por ejemplo, ``kinetic''.
	\item \texttt{string os\_version}: Información sobre el sistema operativo donde se ejecuta el servidor LTM. Por ejemplo, ``GNU/Linux, Ubuntu 16.04, 4.13.0-43-generic, x86\_64''.
\end{itemize}

Luego, se modifica el mensaje \texttt{Episode.msg} como sigue:
\begin{itemize}
	\item \texttt{ltm/Info info}: Se agrega una instancia del mensaje \texttt{Info.msg}, para almacenar los metadatos del episodio.
\end{itemize}

% MODIFICACIÓN DEL MENSAJE ROS
Una vez definido que los mensajes para \textit{streams} y entidades serán almacenados en colecciones propias, queda la definición del mensaje \texttt{What.msg}, encargado de almacenar las referencias a cada dato semántico relacionado al episodio. Para ello, se modifica el mensaje \texttt{Episode.msg}:
\begin{itemize}
	\item \texttt{ltm/What what}: Se agrega una instancia del mensaje \texttt{What.msg}. Sus contenidos son descritos en las siguientes secciones.
\end{itemize}


% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
Considerando lo anterior, se modifica el mensaje \texttt{What.msg} para agregar referencias a los \textit{streams} almacenados.
\begin{itemize}
	\item \texttt{string[] streams}: Listado de \textit{streams} almacenados para el episodio,  referenciados por los nombres de sus colecciones. El identificador del \textit{stream} corresponde al campo \texttt{uid} del episodio.
\end{itemize}

% REPRESENTACIÓN EN EL MENSAJE EPISODE.MSG
\paragraph{Representación:}
% TODO


% modificar msg de colección MD5 y poder seguir ocupando la base de datos.
% - mongo no tiene problema en modificar representación ...
% - el driver ROS si.


Dado que el mensaje definido por el usuario no es conocido en tiempo de compilación (pues los plugins se cargan en runtime)
Para lo anterior, se agrega un nuevo requisito, el usuario debe definir un servicio ROS (archivo \texttt{.srv}) con el siguiente formato:
\lstset{style=/Style/ROS/MSG}
\begin{lstlisting}
Put your code here.
\end{lstlisting}


\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm/Episode.msg,label=lst:episode.msg]{code/msg/Episode.msg}

\subsection{Mensajes definidos por los plugins para Bender}

\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm\_samples/ImageStream.msg]{code/msg/ImageStream.msg}
\lstinputlisting[caption=ltm\_samples/PersonEntity.msg]{code/msg/PersonEntity.msg}
\lstinputlisting[caption=ltm\_samples/ObjectEntity.msg]{code/msg/ObjectEntity.msg}

% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Herramientas para validación}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

\subsection{Episodios JSON}
% - Episodios JSON: comprensión de la estructura a utilizar
.

\subsection{Episodios SMACH}
% - Episodios Smach: cubrir todos los casos de borde
.

\subsection{Robot ficticio}
% generar datos para plugins

% - Robot simulado: emociones y localización fakes

% - Streams Fake: videos.. proveer misma interfaz que el robot

% - Entidades Fake: Generador de campos para mensajes ... no existe interfaz en el robot para esto.

.

% ==============================================================================
% ==============================================================================\\
% ==============================================================================
% ==============================================================================
\section{Servidor LTM}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.
% OVERVIEW
% uso de diseño explicado en la sección X
% implementación completa en C++
% sobre el manejo de la BD episódica utilizando el driver X

% MANEJO DE PLUGINS
% ==============================================================================
% ==============================================================================
\subsection{API pluginlib}
% ==============================================================================
% ==============================================================================

.
\subsubsection{Plugin: \textit{Where}}
% - API
% - convex hull

.
\subsubsection{Plugin: Emociones}
% - API

.
\subsubsection{Plugin: Streams}
% - API
% - Manejo de coleccion

.
\subsubsection{Plugin: Entidades}
% - Manejo de colecciones
% - API

.

% ==============================================================================
% ==============================================================================
\subsection{API ROS}
% ==============================================================================
% ==============================================================================
% API ROS:
% - Disponible a través de C++, Python, Java, Lisp, otros.

.

\subsubsection{Servicios implementados}
% - srv implementados
% - Servicios que provee



\subsubsection{Consultas episódicas}
% - consultas episódicas

.

\subsubsection{Configuración mediante ROS}

.
\lstset{style=/Style/yaml/ROS}
\lstinputlisting[caption=server.yaml]{code/config/server.yaml}

\subsubsection{Launchfiles}



% ==============================================================================
% ==============================================================================
\subsection{Trabajo futuro}
% ==============================================================================
% ==============================================================================
% Trabajo Futuro

.



% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Módulos generadores de información ficticia}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de \textit{Where}}
% ==============================================================================
% ==============================================================================
% WHERE
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de emociones}
% ==============================================================================
% ==============================================================================
% EMOTIONS
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.



% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de imágenes}
% ==============================================================================
% ==============================================================================
% STREAMS EN VIDEO
% - buffer
% - configurable
% - Registro en pluginlib y configuración en el server

\lstset{style=/Style/ROS/MSG}
\lstinputlisting[caption=ltm\_samples/ImageStreamSrv.srv]{code/srv/ImageStreamSrv.srv}

.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de entidades}
% ==============================================================================
% ==============================================================================
% ENTIDADES
% - sólo genera al recolectar... no requiere almacenar buffer
% - configurable
% - Registro en pluginlib y configuración en el server

.



% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
\section{Módulos específicos para Bender}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================

.


% ==============================================================================
% ==============================================================================
\subsection{Interfaz con SMACH}
% ==============================================================================
% ==============================================================================
% INTERFAZ SMACH
% - SOBRE DISEÑO y PYTHON
% - implementación:
%   - registro de episodios y tags
%   - hooks para inicio y fin de episodios
%   - intrusividad: Implementación sin impacto en librería y que minimiza trabajo del equipo
%   - estabilidad: no morir ante nada!
% - test en todos los tipos de estado definidos?
% - ejemplo de funcionamiento
% - REVISAR MATCH CON DISEÑO ESCRITO

.



% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de \textit{Where}}
% ==============================================================================
% ==============================================================================
% INTERFAZ WHERE
% - API del ROBOT
% - buffer y periodicidad
% - selección de posiciones
% - registro y recolección
% - Registro en pluginlib y configuración en el server
% - REVISAR MATCH CON DISEÑO ESCRITO
.

% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de emociones}
% ==============================================================================
% ==============================================================================
% INTERFAZ EMOTIONS
% - API del ROBOT
% - buffer y periodicidad
% - selección de emocion
% - metadatos
% - registro y recolección
% - Registro en pluginlib y configuración en el server
% - REVISAR MATCH CON DISEÑO ESCRITO
% - Funcionalidades implementadas en el robot: 
%    - emociones simples.
%    - módulos disponibles (con el robot a medias)
.


% ==============================================================================
% ==============================================================================
\subsection{Plugin para recolección de imágenes}
% ==============================================================================
% ==============================================================================
% INTERFAZ IMAGES
% - API del ROBOT
.

% ==============================================================================
% ==============================================================================
\subsection{Plugins para recolección de entidades}
% ==============================================================================
% ==============================================================================
% INTERFAZ ENTITIES
% - API del ROBOT
.


% ==============================================================================
% ==============================================================================\\
% ==============================================================================
% ==============================================================================
\section{Integración del sistema en Bender}
% ==============================================================================
% ==============================================================================
% ==============================================================================
% ==============================================================================
% - instalación y convivencia con el software
% - visualización de datos episódicos.
% - Interfaz Robot: Emociones y Posición
% - Streams
% - Entidades

.


