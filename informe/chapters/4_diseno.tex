\chapter{Diseño}\label{chapter:diseno}

En este capítulo se revisa el diseño del sistema LTM implementado en el proyecto. Primero, se presentan todos los requerimientos de diseño y se elabora un conjunto de validaciones que permitirán guiar el diseño, implementación y posterior evaluación del proyecto. Mediante las siguientes 4 secciones se describe la arquitectura del sistema: Se revisa el diseño de los episodios, su estructura de datos y limitantes. Luego se estudia el diseño del modelo de datos para la memoria episódica y su relación con los componentes semánticos. En tercer lugar se presenta el diseño del servidor LTM y sus limitantes. Finalmente, se definen la interfaz episódica y los componentes específicos a implementar para el robot Bender.

\todoimprove{Modificar ocurrencias de campos What, When, Where por versiones \texttt{What, When, Where}} 

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================
\section{Requerimientos y validaciones}
%% =============================================================================
%% =============================================================================
%% =============================================================================

A continuación se presentan los requisitos de diseño sobre los que se construye el proyecto y las validaciones generadas a partir de ellos. Primero se da una descripción breve sobre el origen y razón de los requisitos. Luego, se presenta un listado formal de todos los requerimientos, escritos de una forma clara y verificable. Para concluir, se presenta un conjunto de pruebas que busca validar cada requerimiento expuesto.

%% =============================================================================
%% =============================================================================
%% ============================================================================= 
\subsection{Requisitos del proyecto}
%% =============================================================================
%% =============================================================================
%% =============================================================================

El primer conjunto de requisitos se deriva a partir de los objetivos del proyecto y sus alcances, presentados en la Sección \ref{sec:objetivos}.
\begin{itemize}
\item \RPlabelDef{1} Diseño de memoria de largo plazo episódica y semántica para robots de servicio domésticos, basado en los 11 requerimientos para una memoria episódica planteados por Stachowicz \cite{Stachowicz2012} y presentados en la Sección \ref{sec:ltm_exp}.
\item \RPlabelDef{2} Diseño debe considerar la modulación de los procesos cognitivos mediante memoria emocional.
\item \RPlabelDef{3} El diseño del sistema debe soportar el concepto de relevancia histórica.
\item \RPlabelDef{4} Además, los episodios deben manejar un indicador de relevancia generalizada, que encapsule todos los demás indicadores en sólo uno.
\item \RPlabelDef{5} Diseño del sistema debe ser agnóstico del robot a utilizar.
\item \RPlabelDef{6} El proyecto debe ser integrado en Bender, de manera no invasiva.
\end{itemize}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Requerimientos de sistema}
%% =============================================================================
%% =============================================================================
%% =============================================================================

Se desarrolló un documento (semiformal) de requisitos del sistema, derivados a partir de los requisitos de proyecto revisados en la sección anterior. Cada requisito de proyecto fue reformulado desde su versión difusa, uno o más requisitos de sistema precisos y verificables. El listado de puede ser encontrado en el Apéndice de Diseño, en la Sección \ref{appendix:req-sistema}.

El documento consta de 26 requisitos de sistema, cada una indicado por un prefijo y numeración de la forma \RSlabel{XX}. Cada uno indica su requisito de proyecto asociado. En el Apéndice \ref{chapter:appendix_a}, la Figura \ref{img:trazabilidad} muestra la matriz de trazabilidad de los requisitos de proyecto y sistema definidos.

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Validaciones}
%% =============================================================================
%% =============================================================================
%% =============================================================================

También se desarrolló un documento (semiformal) con validaciones para cada uno de los requisitos de sistema en el documento. Las validaciones sirven como guía para la implementación del proyecto, y sus resultados son presentados y estudiados en el Capítulo \ref{chapter:results}. El listado completo se encuentra en el Apéndice de Diseño, en la Sección \ref{appendix:validations}.

Las validaciones fueron separadas en 5 categorías: 
\begin{enumerate}
	\item \Vlabel{A}{XX} Se verifican directamente desde el diseño e implementación del sistema.
	\item \Vlabel{B}{XX} Verificadas mediante la ejecución del sistema.
	\item \Vlabel{C}{XX} Validaciones de consultas LTM al servidor.
	\item \Vlabel{D}{XX} Validaciones de eficiencia
	\item \Vlabel{E}{XX} Validaciones de escalabilidad.
\end{enumerate}

El documento consta de alrededor de 35 validaciones, cada una indicada por un prefijo y numeración de la forma {\bfseries VTXX} (V: Validación, T: Tipo, XX: numeración). Cada validación indica su requisito de sistema asociado. En las Figuras \ref{img:trazabilidad-VA}-\ref{img:trazabilidad-VB}-\ref{img:trazabilidad-VC} se presentan matrices con el mapeo entre requisitos de sistema y las validaciones definidas.

Las validaciones \Vlabel{D}{XX} tienen por objetivo medir la eficiencia del sistema, una vez integrado en Bender. Se construyen a partir del requisito de sistema \RSlabel{15}. Cada una busca medir el uso de algún recurso del sistema, mientras el servidor se encuentra en funcionamiento y en espera. 

Las validaciones \Vlabel{E}{XX} se construyen a partir del requisito de software \RSlabel{16}. Tienen por objetivo medir el costo en tiempo de las operaciones de inserción, búsqueda y borrado de episodios, en función de la cantidad de episodios almacenados en la base de datos.


%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================
%% =============================================================================
\section{Diseño de episodios}
%% =============================================================================
%% =============================================================================
%% =============================================================================

A continuación presentan las decisiones de diseño seguidas para la representación de los datos episódicos mediante mensajes de ROS. Se estudia el formato a utilizar para el almacenamiento de cada episodio, seguido de la estructura de datos tipo árbol que soporta sus anidamientos. Luego se explica el diseño de los campos episódicos (\textit{What, When, Where}), la representación de la memoria semántica y el manejo de relevancias episódicas. Finalmente, se introducen los metadatos asociados a cada episodio y las limitantes del diseño episódico desarrollado para la representación episódica.

\todoimprove{AGREGAR DIAGRAMA GENERAL DEL SISTEMA... DB -- LTM -- PLUGINS -- USER}
\todoimprove{Agregar diagrama explicando anidamiento, transposición.}

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Formato y representación}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE ELECCIÓN DE MENSAJES DE ROS
\paragraph{Mensaje ROS:}
Se decidió utilizar mensajes de ROS para la representación de episodios. Esto se justifica en la amplia gama de mensajes preconstruidos que provee, los que permiten generar un mensaje adecuado a cualquier necesidad. Además, al utilizar éste sistema de mensajes, se evita definir una formato de información particular para la representación episódica, y la comunicación de episodios mediante la API ROS del servidor se simplifica. Más aún, como se explicará en más detalle en la Sección \ref{}, el driver para MongoDB a utilizar permite almacenar cualquier estructura de datos, mientras ésta esté encapsulada en un mensaje ROS.

% SOBRE UNICIDAD
\paragraph{Unicidad:}
El requisito de software \hl{(RSXX)} exige que cada episodio sea único. Para esto, el mensaje ROS debe contener un campo que identifique al episodio. El servidor debe encargarse de que cada nuevo episodio cuente con un identificador único.

% SOBRE CAMPO DE TAGS
\paragraph{Tags:}
Además, para simplificar la búsqueda y reconocimiento de episodios, se incluye un campo de \textit{tags}. Éste corresponde a un vector de \textit{strings} y permite almacenar descripciones breves sobre la naturaleza del episodio. Por ejemplo, un episodio podría contener los siguientes \textit{tags}: ``cumpleaños'', ``fiesta'', ``atender invitados'' y ``torta''.

 
%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Árboles de episodios}
%% =============================================================================
%% =============================================================================
%% =============================================================================

\todounsure{Quitar manejo de contexto del trabajo??... no se si vale la pena que el server maneje ese concepto. Puede ser trabajo futuro.}

\todounsure{Es correcto hablar de hojas y nodos??... Debo buscar una palabra más adecuada para nodos que no son hojas??.. o debo explicitar que en adelante, cualquier referencia a nodo se refiere a eso. Suena raro hablar de ``padres''.}
\todowrite{Nodo == Nodo interno}

% SOBRE ANIDACIÓN Y ÁRBOLES EPISÓDICOS
\paragraph{Anidamiento episódico:}
A partir del requisito de software \hl{(RSXX)}, se debe soportar el concepto de anidación episódica. Este nace de la capacidad para expresar cualquier episodio, en términos de 1 o más sub-episodios más específicos. Para ello, se definen los \textit{árboles de episodios}, utilizando una estructura de datos de árbol: Las hojas contienen todo episodio que el sistema identifica como no divisible, mientras que cada padre es una representación menos específica de lo sucedido.

% SOBRE TEMPORALIDAD
\paragraph{Temporalidad:}
Para el árbol episódico, es fundamental que cada episodio padre inicie antes que cualquiera de sus hijos, y termine después que todos ellos. 

% SOBRE MANEJO DE INFORMACIÓN EN PADRES E HIJOS
\paragraph{Estrategia de almacenamiento:}
Ya que un padre puede ser representado lógicamente por su conjunto de hijos, se decide utilizar una metodología de almacenamiento que no genere redundancia de información. Sólo las hojas del árbol son las encargadas de manejar la información semántica del episodio, lo que potencialmente corresponde a una gran cantidad de información. Asimismo, las hojas son encargadas de manejar la mayor cantidad de información episódica que sea posible. Las estrategias para esto serán explicadas en sus respectivas secciones. Por lo tanto, los nodos del árbol manejan poca información y la mayor parte de sus datos puede ser calculada recursivamente a partir de sus hijos y de manera automática por el servidor.

% SOBRE EL CONTEXTO
\paragraph{Noción de contexto:}
Es importante enfatizar que no basta que un episodio esté embebido temporalmente en otro para ser considerado un hijo. Pues a pesar de cumplir la condición de temporalidad, puede ocurrir el caso de que ambos episodios sean simultáneos, pero estén ligados a un contexto distinto. Por ejemplo, dado un episodio A (robot está participando la competencia RoboCup - días de duración) y un episodio B (durante la competencia, robot es utilizado para una tarea de uno de los estudiantes, lo que es considerado ajeno a la competencia); a pesar de que A contiene temporalmente a B, se puede decir que B pertenece a otro contexto y debe ser almacenado en un árbol distinto. Esta noción de contexto es importante, y es la razón por la que el servidor debe manejar una cantidad indefinida de árboles episódicos, cada uno identificado por su raíz. Debido lo anterior, cada episodio debe ser almacenado indicando quien es el padre asociado.

 
\todoimplementation{Se puede agregar condición de que hijos son ordenados por tiempo de inicio}
 
%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Contexto temporal: \textit{When}}\label{sec:design_ep_when}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE LOS REQUISITOS
\paragraph{Requisitos:}
De acuerdo al requisito de software \hl{(RSXX)}, los episodios deben almacenar información que indique su contexto temporal (\textit{When}), es decir, cuándo  sucedió. Para esto, la única información de interés a almacenar son los instantes de tiempo que indican el fin y el inicio del episodio.

\todoimplementation{Revisar o modificar implementación.. no estoy seguro como se están manejando los tiempos para los padres... lo lógico sería no ajustar los tiempos a los de los hijos, pues estos pueden no estar definidos hasta el final!... O agregarlo como limitante.}
% SOBRE MANEJO DE INFORMACIÓN
\paragraph{Estrategia de almacenamiento:}
En el caso de las hojas del árbol, basta utilizar los instantes de tiempo obtenidos al iniciar y finalizar el episodio. Sin embargo, para el caso de los \hl{nodos}, se pueden seguir dos estrategias: Utilizar los instantes de tiempo iniciales y finales percibidos, o calcular automáticamente los tiempos de inicio y fin para ajustarse a los hijos. A pesar de que la segunda opción suena razonable, está asumiendo que siempre existirá un hijo para cada instante de tiempo de vida del padre, lo que puede no ser cierto. Por lo tanto, se deben manejar cuidadosamente los valores de tiempo de los padres, para asegurar que no son sobre-escritos por sus hijos, y para asegurar que los padres siempre contienen temporalmente a cada hijo.


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Contexto espacial: \textit{Where}}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE LOS REQUISITOS
\paragraph{Requisitos:}
De acuerdo al requisito de software \hl{(RSXX)}, los episodios deben almacenar información que indique su contexto espacial (\textit{Where}), es decir, dónde sucedió. A continuación se explican las decisiones de diseño consideradas.

% SOBRE DURACIÓN DE EPISODIOS Y VECTORES
\paragraph{Desplazamiento durante episodios:}
En primer lugar, dependiendo de la duración del episodio, el robot puede haber estado en más de un lugar durante ese tiempo. Esto no es válido sólo para episodios nodo, sino que también para hojas, cuando éstas representan acciones de desplazamiento del robot. Luego, es importante que cada episodio registre cada uno de los lugares en los que ha estado el robot. El listado de lugares debe ser almacenado ordenadamente y con la hora asociada a cada desplazamiento, lo que es importante por dos motivos: permite calcular la secuencia de movimientos para los padres, y permite reconstruir la ruta del robot durante cada episodio. Para ello, la posición del robot puede ser consultada periódicamente en busca de cambios, para almacenar sólo los instantes que indiquen movimiento.
\todoimplementation{Soportar más de 1 lugar semántico y coordenado para hijos.}


% SOBRE USO DE AMBAS OPCIONES: Lugares y coordenadas
\paragraph{Estrategias de almacenamiento:}
La información espacial puede ser manejada de dos maneras: se pueden almacenar los nombres de los lugares en donde el robot estuvo durante el episodio, o se puede almacenar la ubicación precisa del robot durante el episodio, mediante coordenadas relativas a un sistema coordenado predefinido. La decisión sobre cual sistema utilizar depende mucho del contexto en el cual funciona el robot. Por ejemplo, en el caso de Bender, hay ocasiones en donde sólo es posible conocer su ubicación respecto a un sistema coordenado, mientras que en otras oportunidades, sólo se tiene conocimiento verbal de ésta. Luego, ya que no existe un consenso sobre que opción es la mejor, y para evitar limitar la usabilidad del sistema LTM, se decidió dar soporte a ambas alternativas.
\todounsure{Todo todo todo debe estar en 3ra persona singular presente??? como hablo de decisiones pasadas??... según esto, corregir todos los párrafos.}

% OPCIÓN SEMÁNTICA
\paragraph{Estrategia 1 - Descripción:}
Los nombres de lugares en los que estuvo el robot durante el episodio pueden ser almacenados utilizando vectores de \textit{strings}. Considerando el ambiente en donde puede desempeñarse un robot de servicio doméstico, se decide almacenar esta información en dos niveles de profundidad. El primer nivel corresponde a una descripción específica de la ubicación del robot (ej., ``Comedor''), mientras que el segundo sirve para almacenar el nombre del área donde se encuentra la primera ubicación (ej., ``Casa de John''), junto a otras de similar tamaño semántico. En el caso de los episodios nodo, se ha decidido calcular automáticamente toda esta información, a partir de los episodios hijo.
\todoimplementation{Crear submensaje para Where.msg, que almacene: location, area, time}

% OPCIÓN COORDENADAS
\paragraph{Estrategia 2 - Coordenadas:}
Similarmente al caso anterior, las coordenadas de lugares son almacenadas en vectores de puntos, junto con su hora y sistema de coordenadas asociados. Además, para cada punto se debe almacenar el nombre del mapa en donde se define el sistema coordenado. Ya que el proyecto está orientado a robots de servicio doméstico, se ha decidido implementar solamente ubicaciones en 2 dimensiones, es decir, cada punto sólo considera 2 valores numéricos. En el caso de los padres se sigue la siguiente estrategia: las posiciones son obtenidas a partir de sus hijos, se agrega un campo para almacenar la envoltura convexa de todas las posiciones, y se agrega un campo indicando el centroide de ésta.
\todoimplementation{Modificar implementación para agregar soporte a más de un frame/mapa.}
\todoimplementation{Crear submensaje para Where.msg, que represente ubicación coordenada múltiple}

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Memoria semántica: \textit{What}}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% REQUISITOS
\paragraph{Requisitos:}
De acuerdo a los requisitos de software \hl{(RSXXX), (RSXXX)}, la memoria semántica (\textit{What}) ligada a un episodio permite describir `qué'' sucedió en él. Ésta debe poder  contener cualquier dato, por lo que no es posible establecer de antemano qué información y estructura debe ser utilizada, sino que ésto debe poder ser definido por el usuario. El requisito \hl{(RSXXX)} (regla de flexibilidad episódica) establece que cada episodio debe permitir crear nuevos datos semánticos o actualizar los ya existentes. El requisito \hl{(RSXXX)} (regla de perspectiva episódica) exige que al leer un episodio, éste pueda describir sus datos semánticos asociados, de acuerdo a la misma perspectiva que se tenía de ellos cuando el episodio fue ejecutado.


% SEPARACIÓN DE CONCEPTOS
\paragraph{Streams y entidades:} 
La memoria semántica maneja entidades conocidas por el robot e información sobre ellas. Por ejemplo, se puede definir la entidad ``persona'' y almacenar datos como su nombre, nacionalidad o la fecha de la última interacción registrada. Sin embargo, existe un tipo de información que no está asociada a alguna entidad en particular, correspondiente a datos en forma de flujos de información (\textit{streams}). Éstos permiten registrar secuencias de imágenes, sonido y otros conceptos basados en flujos de datos percibidos por el robot, especialmente los obtenidos directamente desde sus sensores. Otra característica de los \textit{streams}, es que a diferencia de las entidades, representan datos que no se desea actualizar posteriormente, pues almacenan una imagen de lo percibido en el instante, la que generalmente es invariable. Entonces, se decide separar la memoria semántica en dos componentes, \textit{streams} y entidades, lo que permite diseñar estrategias de procesamiento adecuadas al funcionamiento de cada uno.


% GENERALIZANDO MEMORIA SEMÁNTICA
\paragraph{Generalización:}
Ya que los contenidos a almacenar deben poder ser definidos por el usuario, se establecen las siguientes decisiones de diseño. En primer lugar, el usuario debe definir que información utilizará, mediante uno o más mensajes de ROS. Segundo, éstos mensajes deben tener un campo para almacenar un identificador único. Los episodios deben tener referencias al tipo del mensaje asociado y a sus identificadores únicos. Similarmente, cada mensaje definido debe tener un campo para almacenar el identificador único de su episodio relacionado. Lo anterior es válido tanto para \textit{streams} como entidades.

\todopaused{Episodio almacena tags para describir entidades y cambios?.}


% SOBRE PLUGINS
\paragraph{Sistema de plugins:}
Se decidió utilizar un sistema basado en \textit{plugins}, para manejar los mensajes ROS definidos por el usuario. El diseño del servidor LTM en la Sección \ref{} especifica que funcionalidades deben ser implementadas por \textit{plugins} destinados a \textit{streams} o entidades. De esta manera, se delega al usuario la implementación de los algoritmos para adquisición de información semántica y procesamiento de ésta.


% SOBRE STREAMS
\paragraph{Datos semánticos - Streams:}
Los \textit{streams} corresponden a flujos de datos generalmente invariables. Cada episodio puede estar asociado a uno o más \textit{streams}, y a su vez, cada \textit{stream} puede contener uno o más datos. El servidor debe proveer notificaciones para indicar el inicio y fin de un episodio, mientras que el usuario debe definir su estrategia para adquirir datos durante ese lapso de tiempo. Por ejemplo, en el caso de un \textit{stream} de imágenes representando la visión del robot, y cuyo fin sólo sea de visualización a futuro, el usuario podría almacenar una imagen cada 3 segundos. 

Según la cantidad de \textit{plugins} a utilizar y la periodicidad de recopilación de información, el espacio de disco requerido para almacenar los mensajes puede ser agotado rápidamente. Para solucionar esto hay 3 alternativas. En primer lugar, se puede expandir la memoria disponible, lo que no es una solución real. En segundo lugar, está el ``olvido'' de información, mediante la eliminación de datos antiguos (posiblemente previo respaldo en otra máquina) o eliminar datos intercaladamente. La tercera opción es la degradación de información, para lo que cada usuario debe implementar un algoritmo que disminuya el tamaño de sus mensajes (por ejemplo, disminuyendo la resolución o cantidad de las imágenes del episodio). Ya que las dos primeras opciones pueden ser ejecutadas manualmente por el usuario, se ha decidido utilizar la degradación de mensajes. Esta estrategia puede ser aplicada automáticamente a mensajes antiguos y de baja relevancia episódica.

\todoimplementation{LTM server con warning en texto y notificación inotify cuando quede poco espacio de disco (menor a X\%) (o se ha ocupado más de X GB) debido al server... configurable por usuario...}


% SOBRE ENTIDADES
\paragraph{Datos semánticos - Entidades:}
% - manejo de datos y relaciones para regla perspectiva
% - manejo de datos y relaciones para flexibilidad
.

\todoimplementation{Manejo de perspectiva y audit al requerir insertar episodio al medio (temporalmente) de otros ya existentes.}

\todopaused{Escribir tras tener primera implementación razonable}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Relevancia generalizada}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% RELEVANCIA GENERALIZADA
\paragraph{Requisitos:}
De acuerdo a los requisitos de software \hl{(RSXX), (RSXX) y (RSXX)}, los episodios deben almacenar información de relevancia episódica. Estos indicadores son importantes al momento de buscar episodios, para poder ordenarlos de acuerdo a una medida de importancia, y así tener una pista sobre cuales enfocar la atención. El sistema debe soportar, al menos, la noción de relevancia histórica y emocional, considerando que en un futuro se podrían agregar otros indicadores de relevancia. También, el sistema debe proveer un indicador generalizado, capaz de representar la relevancia global del episodio, mediante un solo indicador numérico que unifique las sub-relevancias.


% MANEJO DE INDICADORES
\paragraph{Estrategia de almacenamiento:}
Entonces, se define la siguiente estrategia de almacenamiento. Cada tipo de indicador debe proveer un valor numérico en el rango $[0, 1]$, que represente la importancia del episodio de acuerdo a su perspectiva. Un valor de 0 significa que el episodio no es relevante, mientras que el valor 1 es utilizado para indicar que el episodio es muy importante. Utilizando el formato anterior, se construye el indicador de relevancia generalizada a partir de todas las sub-relevancias definidas para el episodio. Este indicador debe ser actualizado cada vez que una sub-relevancia sea modificada o ingresada.


% COMPUTO BASADO EN ALGORITMO X
\paragraph{Cómputo:}
Este proyecto sólo considera dos sub-indicadores, histórico y emocional, por lo que se decidió utilizar la metodología propuesta por \hl{XXX} \cite{} y explicada en la Sección \ref{}.
\todopaused{Escribir más cuando esté implementado}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Relevancia emocional}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% RELEVANCIA EMOCIONAL
\paragraph{Requisitos:}
El requisito de software \hl{(RSXXX)} exige el manejo del concepto de relevancia emocional, como un medio para almacenar las emociones ``que tiene'' el robot durante un episodio, en conjunto a un indicador de la intensidad de éstas.


% ABSTRACCIÓN DEL SISTEMA DE EMOCIONES
% - sobre EMOCIONES VÁLIDAS
\paragraph{Abstracción del sistema emocional:}
Según se revisó en la Sección \ref{}, existen diversas sistemas emocionales para la generación de emociones. No existe una metodología única para el cómputo de emociones, por lo que cada sistema es alimentado con datos diferentes, utilizan algoritmos distintos y proveen salidas distintas. Debido a la generalidad esperada de este proyecto, la forma de representar la emoción es se abstrae del sistema emocional a utilizar. Para esto, en primer lugar se define un conjunto de emociones base, a partir del modelo emocional de Plutchik descrito en la Sección \ref{}, con las que se debe construir la emoción asociada al episodio, mediante una combinación de ellas. Luego, se decidió utilizar un sistema de plugins, para que el usuario defina cómo realizar la asignación desde las salidas de su sistema emocional, a la combinación de emociones base disponibles para un episodio. Es así, como la asignación emocional se puede  abstraer de la implementación y delegar al usuario encargado de la plataforma objetivo.


% CAMPOS REQUERIDOS
\paragraph{Estrategia de almacenamiento:}
En primer lugar, se define un conjunto de 8 emociones base para la representación emocional (alegría, confianza, miedo, sorpresa, tristeza, disgusto, enfado y anticipación). El diseño considera sólo el almacenamiento de la emoción más importante durante la duración del episodio, la que es asociada a una emoción del conjunto base. Luego, siguiendo el estándar definido para representación de relevancias, se agrega un valor numérico en el rango $[0, 1]$, para  indicar la intensidad de la emoción seleccionada. Para el caso de episodios nodo, el valor emocional es calculado automáticamente a partir de los hijos. Para esto, se utiliza un vector de 8 valores, destinados a cada una de las 8 emociones base, donde se almacena el valor máximo de cada emoción presentado por sus hijos.

% METADATOS
\paragraph{Metadatos:}
Además, para simplificar la introspección de episodios a futuro, se decide agregar metadatos para indicar: software emocional utilizado y su versión, conjunto de salidas registradas por el software emocional y sus valores de intensidad. Es importante enfatizar que estos datos sólo deben ser utilizados para introspección y no tienen influencia en el cálculo de ninguna relevancia.
\todolater{Actualizar esto en caso de modificar metadatos}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Relevancia histórica}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE RELEVANCIA HISTORICA
\paragraph{Requisitos:}
El requisito de software \hl{(RSXXX)} exige el manejo del concepto de relevancia histórica, como un medio para indicar la importancia de un episodio, según su edad en la base de datos. 

% ALMACENAMIENTO
\paragraph{Estrategia de almacenamiento:}
Siguiendo el estándar definido para representación de relevancias, se utiliza un valor numérico en el rango $[0, 1]$, para  indicar el estado de envejecimiento del episodio. Este valor siempre debe ser inicializado en 1, para decaer hacia 0 con el paso del tiempo.


% MANEJO AUTOMÁTICO DE DATOS HISTÓRICOS
\paragraph{Actualización automática:}
El valor de la relevancia debe ser manejado automáticamente por el servidor LTM. Existen diversas formas de actualizar este valor, pero tras una revisión bibliográfica, se decidió utilizar la siguiente estrategia. Se propone disminuir el indicador, según el algoritmo de decaimiento estudiado por XXX en \cite{} y presentado en la Sección \ref{}. Ya que se espera almacenar una gran cantidad de episodios, se propone actualizar el valor cada lapsos cada vez más espaciados en el tiempo (por ejemplo, primero cada 1 día, luego 1 vez a la semana, cada 1 mes, cada 1 año), lo que permite acotar el esfuerzo computacional dedicado a las actualizaciones.

\todopaused{Sobre la tasa de decaimiento histórica implementada.}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Datos para introspección}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE RAZONAMIENTO
\paragraph{Metadatos:}
El último conjunto de datos considerado para almacenar junto a cada episodio es denominado \textit{Metadatos}. Éstos no están ligados a algún requerimiento de software, por lo que no son formalmente necesarios, sin embargo, permiten almacenar datos útiles para la implementación LTM, y sirven para conocer información sobre el software utilizado para almacenar cada episodio. Los \textit{Metadatos} tienen como finalidad ser de utilidad al resolver problemas relacionados al software LTM, y para cuando los usuarios deseen conocer el contexto de software sobre el cual fue generado el episodio.


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Limitantes y trabajo futuro}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE LIMITANTES DEL DISEÑO Y TRABAJO FUTURO

A continuación se presenta un conjunto de limitantes conocidas del diseño episódico desarrollado, las que pueden ser consideradas como parte del trabajo futuro del proyecto.

% SOBRE COMPLETITUD Y LAPSOS EN BLANCO..
\paragraph{Ausencia de hijos:} Este problema fue explicado parcialmente en la Sección \ref{sec:design_ep_when}, y aparece con padres cuyo rango temporal no es cubierto completamente por sus hijos. Cómo se verá en la Sección \ref{}, esto puede suceder cuando el usuario decide no almacenar algunos episodios hoja, pues los considera poco relevantes. El efecto de ésto, es que puede haber información no presente en los padres, al calcular sus datos a partir de sus hijos. Particularmente, esto sucede con la información para \textit{When}, \textit{What} y las relevancias episódicas. Se puede argumentar que, ya que el usuario considera que los subepisodios eran irrelevantes, entonces la información perdida también lo es. Sin embargo, por motivos de introspección, puede ser de interés almacenar los datos de \textit{streams} asociados a los periodos temporales perdidos.

\paragraph{Episodios de larga duración:}
A pesar de que el diseño del servidor permite episodios de duración indefinida, en la práctica, es raro que el robot funcione por periodos prolongados. Luego, los episodios cuyo fin es dar un contexto temporal a un árbol no pueden ser almacenados directamente (por ejemplo, cuando el robot está participando en una competencia de 4 días de duración). A pesar de lo anterior, el diseño permite la introducción manual de episodios de larga duración, sin tener que mantener en funcionamiento el robot durante todo el periodo.

\todoimplementation{COMO MANEJAR CONTEXTOS, PUES SE PUEDE REQUERIR SU INFORMACIÓN, INCLUSO DURANTE EL MISMO EPISODIO!!.. DEBEN SER ALMACENADOS UNA VEZ INSCRITOS Y SER CERRADOS MANUALMENTE.}


\todowrite{Limitante Where: En un futuro se podría agregar un 3er nivel de información, para almacenar info ultra específica, por ejemplo: ``al lado de la tele'', ``cerca del refrigerador''..}


% SOBRE UBICACIÓN
\todopaused{Depende de reimplementación del sistema de ubicación}

%       - ubicación 2D
%       - ubicación y frames
%       - ubicaciones de hojas con sólo un lugar... vs episodios con movimiento.
%       - padres mantienen con mismo frame y mapa de hijos


%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================
%% =============================================================================
\section{Diseño del modelo de datos}
%% =============================================================================
%% =============================================================================
%% =============================================================================
% - Diseño de Base de Datos:

Es esta sección se presentan las decisiones sobre el diseño de la base de datos a utilizar para el proyecto. En primer lugar, se revisan las consideraciones sobre la base de datos escogida: \textit{MongoDB}. Luego, se describe el manejo de mensajes episódicos y sus datos semánticos asociados, \textit{streams} y entidades.


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Base de datos}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE SELECCIÓN DE MONGO DB
\paragraph{MongoDB:}
Según se explicó en la Sección \ref{}, la implementación del sistema LTM requiere el manejo de datos aleatorios, representados mediante mensajes de ROS que debe definir el usuario. Además, el sistema debe permitir modificar la representación de tales mensajes a futuro y soportar el almacenamiento de datos binarios. Por lo tanto, se requiere el uso de una base de datos no relacional, capaz de manejar cualquier mensaje definido en ROS. Para ésto, se decidió utilizar la base de datos no relacional \textit{MongoDB}, presentada en la Sección \ref{}. 

La decisión sobre el uso \textit{MongoDB} se basa en tres razonamientos principales. Primero, el driver ROS para ésta es considerado estable, al menos hasta el año 2023. \textit{MongoDB} es utilizado por la librería \textit{MoveIt} de ROS, de uso extendido en la comunidad, por lo que ya ha sido probada y está disponible en muchos robots de servicio domésticos. Finalmente, \textit{MongoDB} se ocupa actualmente en el robot Bender. Debido a lo anterior, esta elección minimiza problemas de dependencias y compatibilidad a futuro.

\todounsure{Es correcto hablar de drivers??.. debo hablar sobre controladores?..}


% SOBRE SEPARACIÓN DE COLECCIONES
\paragraph{Colecciones:}
Debido al funcionamiento del driver ROS para \textit{MongoDB}, se asociará una colección distinta para cada mensaje episódico de interés. Particularmente, una colección será destinada al almacenamiento del mensaje \texttt{Episode.msg}, mientras que cada mensaje definido por el usuario será  asociado a una colección distinta. En primera instancia, la base de datos no relacional permitiría almacenar todos los mensajes en la misma colección, pero la separación de cada tipo de dato en colecciones distintas es conveniente debido a lo siguiente. Primero, la separación permite optimizar consultas simples a la base de datos, que no requieran acceder a toda la memoria semántica asociada. Además, mediante la separación se evita propagar problemas al registro de episodios, cuando se presenten fallos en los controladores de memoria semántica que debe implementar el usuario. Finalmente, ya que el sistema debe soportar una cantidad indefinida de mensajes ROS elegidos por el usuario, se evita saturar el registro de episodios con mensajes que, una vez agrupados, superen el límite de tamaño permitido a cada elemento de una colección.

% REQUISITO DE MODIFICACIÓN DE REPRESENTACIÓN
% modificar msg de colección MD5 y poder seguir ocupando la base de datos.
% - mongo no tiene problema en modificar representación ...
% - el driver ROS si.
.
\todopaused{Describir cuando esté solucionado.}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Colección de episodios}
%% =============================================================================
%% =============================================================================
%% =============================================================================

Toda la información episódica, definida por medio del mensaje \texttt{Episode.msg}, será almacenada en la colección \texttt{episodes}.

Debido a los requisitos de software \hl{(RSXX) y (RSXX)}, cada episodio debe ser indexado por todos sus campos disponibles, propuestos en la Sección \ref{}. Sin embargo, por temas prácticos, no es posible indexar todos los datos asociados al campo \textit{What}. En el caso de entidades, queda a criterio del usuario. Mientras que en el caso de \textit{streams}, no tiene sentido indexar cada pixel de una imagen, o cada instante de sonido a almacenar.


% SOBRE CONSULTAS QUE DEBE SOPORTAR?
\todowrite{Sobre consultas episódicas que debe soportar el modelo.}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Colecciones de streams}
%% =============================================================================
%% =============================================================================
%% =============================================================================

Según se explicó anteriormente, cada \textit{stream} definido por el usuario es asociado a una colección de \textit{MongoDB} propia. El nombre de la colección debe ser definido por el usuario. 

Ya que los \textit{streams} se consideran datos con sólo una instancia por cada episodio, se decide utilizar el mismo identificador único para ambas estructuras. Así, el episodio identificado por el valor $A$, tendrá asociado un \textit{stream} de cada colección, cada uno con el identificador $A$.

\todoimplementation{Que el server avise si hay colecciones con nombres repetidos.}

Por lo general, los campos de un \textit{stream} no requieren ser indexados, ya que es conveniente almacenarlos como campos binarios. Sin embargo, durante la implementación del \textit{plugin} asociado, el usuario puede decidir añadir metadatos para indexar campos convenientes. La utilidad de ésto, es que permitirá agregar nuevos términos de comparación para las consultas a la base de datos. Luego, se tienen dos formas de acceder a un \textit{stream} en particular; mediante su mensaje episódico asociado, o a través de los metadatos definidos por el usuario.

Utilizando la configuración por defecto de \textit{MongoDB}, el límite de tamaño para cada mensaje ROS a almacenar es de $16 MB$, lo que impone una cota superior a la cantidad de datos que pueden ser almacenados por cada episodio. Por ejemplo, esto permitiría almacenar $N$ imágenes a color de tamaño $AxB$, o $M$ imágenes en escala de grises del mismo tamaño. Sin embargo, \textit{MongoDB} provee estrategias de almacenamiento que no consideran esa limitante, las que deben ser configuradas por el usuario.
\todowrite{Corregir comparación de 16MB con cantidad de imágenes. Ojo con formato y serialización.}
\todoimplementation{Server con warning si mensaje a almacenar pesa más del límite!.}

% - cambio de representación (MD5)
\todopaused{Sobre la modificación de la estructura del stream... MD5...}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Colecciones de entidades}
%% =============================================================================
%% =============================================================================
%% =============================================================================

Cada mensaje ROS definido por el usuario, para representar una entidad de la memoria semántica, es  asociado a una colección de \textit{MongoDB} propia. El nombre de ésta debe ser definido por el usuario. 

A diferencia de los \textit{streams}, cada episodio puede estar asociado a una o más instancias de una entidad semántica. Por ejemplo, dada una entidad ``Persona'', durante un mismo episodio se pueden obtener datos (e.g., fecha de última visualización) para las instancias ``Jonh'' y ``Mike'', los que son almacenados en la misma colección, pero en distintas entradas.

\todoimplementation{Escribir cuando esté implementado correctamente.}

\todopaused{Sobre modelo de datos y flexibilidad...}
\todopaused{Sobre modelo de datos y perspectiva...}
% - cómo cumplir reglas sobre flexibilidad y perspectiva. Audit trail.

% SOBRE CONSULTAS QUE DEBE SOPORTAR?
\todowrite{Sobre consultas episódicas que debe soportar el modelo.}
\todopaused{Sobre metadatos}
\todopaused{Sobre tags definidos en campo What.}

% - cambio de representación (MD5)
\todopaused{Sobre la modificación de la estructura de entidades... MD5...}



%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Limitantes y trabajo futuro}
%% =============================================================================
%% =============================================================================
%% =============================================================================

El modelo de datos descrito está diseñado para satisfacer los requerimientos de software del proyecto, sin embargo, los siguientes aspectos no son cubiertos por el diseño y se consideran trabajo futuro.

\todowrite{Identificar más limitantes}
% - otras funcionalidades de interés: bkp, migrate a otro robot, ...
% - metadatos de arreglos... por el driver ROS...
% - cosa MD5


%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================
%% =============================================================================
\section{Diseño del servidor LTM}
%% =============================================================================
%% =============================================================================
%% =============================================================================
%    - TODO: manejo de contexto
.
\todowrite{Escribir descripción de la sección.}

% revisar requerimientos software asociados.

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Manejo de episodios}
%% =============================================================================
%% =============================================================================
%% =============================================================================
% - Diseño del servidor LTM según requisitos
% - uso de MongoDB
% - Minimizar dependencias
% - API ROS: servicios, parámetros, nodos
% - parámetros (dar énfasis en la implementación)
% - estrategia de actualización episódica... branching.. etc.
.

\subsubsection{Interfaz episódica}
%% =============================================================================
% - proveer tiempo y anidamiento
% - permite notificar a los otros componentes para la recopilación de información episódica


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Sistema de plugins}
%% =============================================================================
%% =============================================================================
%% =============================================================================
% - Sistema de plugins para agregar cosas específicas a cada robot
%    - where, emociones, streams y entidades.
%    - sobre información disponible para cada plugin
%    - requerimientos para cada plugin
%    - uso esperado de pluginlib
%    - flujo de trabajo de cada plugin
%    - se recomienda que sólo estén en funcionamiento cuando hay episodios registrados pendientes.
%    - sobre estabilidad de plugins.
.

\subsubsection{Plugin: \textit{Where}}
%% =============================================================================
% SOBRE: Funcionamiento recomendado del plugin
% - recopilación constante de posicionamiento del robot.
% - provee listado de poses dado tiempos de inicio, fin de episodio.
% - sólo recopila información cuando hay episodios registrados.
.

\subsubsection{Plugin: Emociones}
%% =============================================================================

% SOBRE: funcionamiento recomendado del plugin
% - recopilación de emociones .. buffer
% - provee emoción más fuerte del periodo.
% - rellenar metadatos 
% - sólo recopilar info si hay episodios registrados.
.

\subsubsection{Plugin: \textit{Streams}}
%% =============================================================================

% SOBRE: requerimientos del server
% - sobre marcar inicio, fin
% - sobre definición de colección
% - sobre manejo de la colección: CRUD
% - sobre API ROS asociada.
.

\subsubsection{Plugin: Entidades}
%% =============================================================================

% SOBRE: requerimientos del server
% - sobre marcar inicio, fin
% - sobre definición de colecciones
% - sobre manejo de la colección: CRUD
% - sobre API ROS asociada.
.

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Alcances y trabajo futuro}
%% =============================================================================
%% =============================================================================
%% =============================================================================
%    - Alcances y trabajo futuro
%        - reservar ids mientras nodo esté activo.
%        - posibles funcionalidades de interés: 
%           - visualizador
%           - 
 .

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================

%% =============================================================================
%% =============================================================================
%% =============================================================================
\section{Diseño de módulos específicos para Bender}
%% =============================================================================
%% =============================================================================
%% =============================================================================

Según especifica el requisito de software \hl{(RSXX)}, el proyecto debe ser integrado al robot Bender, con una demostración de las capacidades del sistema LTM. Para esto, se deben implementar módulos de software que permitan recolectar todos los datos episódicos requeridos por el servidor. A continuación se describe el diseño de los componentes a implementar: la interfaz para recolectar episodios, la posición del robot y sus emociones, junto a los plugins para la recolección de streams y entidades a partir de la memoria de trabajo. 

Cada uno de los módulos presentados a continuación cumple una doble funcionalidad. En primer lugar, cumplen con el requisito del diseño de componentes orientados a robots de servicio doméstico, enfocados en el robot Bender. Y además, sirven como ejemplo para el diseño e implementación de nuevas funcionalidades requeridas a futuro para otras plataformas.

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Recolección de episodios: SMACH}
%% =============================================================================
%% =============================================================================
%% =============================================================================

\paragraph{SMACH:}
El módulo específico más importante a implementar corresponde al encargado de generar episodios a partir del funcionamiento del robot, para luego entregarlos al servidor LTM. Como se explica en la Sección \ref{}, en Bender se utiliza la librería SMACH para la definición y ejecución de las máquinas de estado encargadas de encadenar rutinas simples, para generar comportamientos complejos. A través de SMACH, en Bender se implementan capacidades como la interacción continuada con humanos y la resolución de tareas en el hogar. 

\paragraph{Información episódica:}
A partir de SMACH se puede obtener parte del conocimiento episódico requerido para la definición de un episodio. Desde el punto de vista de sus transiciones, las máquinas de estado están estructuradas en forma de grafo, estableciendo un inicio y fin temporal para cada estado. Conceptualmente, las máquinas se estructuran en forma de árboles, donde cada maquina de estado puede ser contenida por otra, lo que representa el anidamiento episódico. Luego, SMACH provee una forma de conocimiento episódico, capaz de representar información temporal (\textit{When}) y las relaciones de anidamiento episódico (referencias padre-hijo). Finalmente, ya que cada máquina de estado está asociada a una capacidad o contexto, se puede utilizar esa información para obtener los \textit{tags} requeridos para marcar cada episodio.

\paragraph{Funcionamiento:}
La interfaz episódica diseñada tiene 2 etapas importantes. En primer lugar, el durante la programación de la máquina, el desarrollador debe indicar que estados considera almacenar como episodio, en caso que sean ejecutados. Además, se deben para cada estado marcado, se debe indicar una lista de \textit{tags} que describan brevemente el estado. La segunda etapa ocurre durante el funcionamiento de la máquina de estado; Al inicio de cada estado, la interfaz debe registrar el episodio en el servidor e indicar el identificador de su estado padre, para recibir el identificador generado para tal estado. Al fin de cada episodio, debe notificar el cierre al servidor, para que éste ejecute las rutinas de recopilación de datos y almacene el episodio.


\paragraph{Estabilidad de la implementación:}
La ejecución ininterrumpida de SMACH durante una rutina crucial para el desempeño del robot. Si la librería deja de funcionar repentinamente o se detiene continuamente, el robot se detendrá o tomará mucho tiempo en realizar sus tareas, lo que durante una competencia puede tener pésimas consecuencias para el equipo. Es por esto, que la implementación de la interfaz entre el servidor LTM y SMACH debe ser estable. Particularmente, es de vital importancia que el funcionamiento de SMACH no se vea afectado por la implementación, independientemente de si ésta tiene problemas en su ejecución. 


\paragraph{Intrusividad:}
Por otro lado, la implementación debe minimizar las modificaciones a la librería SMACH y a las máquinas de estado ya implementadas. En primer lugar, si se modifica la librería SMACH, el equipo tendrá que agregar una copia de ésta y mantenerla a futuro, para lo que no hay personal ni tiempo suficiente. Segundo, el robot dispone de muchas máquinas de estado, las que deberán ser actualizadas para agregar la funcionalidad de la interfaz episódica. Por lo tanto, se toman las siguientes decisiones:
\begin{itemize}
\item La librería SMACH no puede ser modificada para la implementación de la interfaz.
\item Las modificaciones a las máquinas de estado deben ser mínimas y opcionales. Esto permitirá ir agregando soporte LTM de manera gradual al robot.
\end{itemize}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Recolección de dato episódico: \textit{Where}}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE plugin
Se debe implementar un plugin para Bender capaz de proveer la posición del robot durante cada episodio, según los requerimientos especificados en la Sección \ref{}. Por motivos prácticos, se consideran dos versiones a implementar, una con información falsa, y otra capaz de obtener datos reales desde el robot.

% SOBRE: Plugin con información Dummy
La versión ``de prueba'' debe proveer datos generados aleatoriamente para cada uno de los campos del mensaje \texttt{Where.msg}. La motivación para esto, es poder realizar pruebas durante la implementación del sistema y poder ejecutar validaciones que no precisen de la ubicación real del robot. Además, el plugin permite minimizar el uso del robot real para la implementación y validación del proyecto, pues el robot es un recurso compartido en el equipo de trabajo y su uso implica costos altos en términos de tiempo.

% SOBRE: Interfaz con robot Bender.
La segunda versión debe ser integrada en el software del robot, a través de la API para la obtención de su ubicación. Se utilizará la estrategia de funcionamiento recomendada en la Sección \ref{}. El plugin deberá recopilar información periódicamente para cada uno de los campos del mensaje \texttt{Where.msg}. Se deberá proveer un listado ordenado temporalmente de las ubicaciones recopiladas, cuando el servidor notifique el término del episodio. Para disminuir el uso de recursos, solamente se deben recopilar posiciones cuando hayan episodios registrados como pendientes en el servidor.
\todoimplementation{Plugin Where en Bender.}


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Recolección de dato episódico: Emociones}
%% =============================================================================
%% =============================================================================
%% =============================================================================

% SOBRE: plugin
El siguiente plugin a implementar está encargado de proveer las emociones registradas por el robot durante cada episodio, según los requerimientos especificados en la Sección \ref{}. En este caso, también se consideran dos versiones a implementar, una que provee datos falsos, y otra capaz de obtener datos reales desde el robot. Ambas versiones deben recopilar datos para cada uno de los campos del mensaje \texttt{Emotion.msg}.

% SOBRE: plugin dummy
La versión ``de prueba'' debe proveer datos generados aleatoriamente para cada uno de los campos del mensaje \texttt{EmotionalRelevance.msg}. Similarmente al plugin para el campo \textit{Where}, este plugin permite realizar pruebas durante la implementación del sistema y ejecutar validaciones que no precisen de la emoción real del robot, mientras se minimiza el uso del robot. Sin embargo, la razón principal para su implementación es que actualmente el robot no cuenta con un sistema de emociones.

% SOBRE: Interfaz con robot Bender.
La segunda versión debe ser integrada con el software del robot, una vez que se haya implementado el sistema emocional en el robot. Para ésto, se utilizará la estrategia de funcionamiento recomendada en la Sección \ref{}. El plugin deberá recopilar información periódicamente sobre las emociones del robot. Una vez que el servidor notifique la finalización del episodio, el plugin debe proveer un mensaje \texttt{Emotion.msg} asociado a la emoción más intensa durante la duración de éste. Además, para disminuir el uso de recursos, solamente se debe recopilar información cuando hayan episodios registrados como pendientes en el servidor.

\todopaused{Hablar sobre el diseño de módulos emocionales para el robot}

\subsubsection{Modulo emocional: A}
%% =============================================================================

\subsubsection{Modulo emocional: B}
%% =============================================================================

\subsubsection{Modulo emocional: C}
%% =============================================================================

\subsubsection{Modulo emocional: servidor de emociones}
%% =============================================================================


%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Plugin para streams: Imágenes}
%% =============================================================================
%% =============================================================================
%% =============================================================================


% SOBRE: plugin
Para los plugins encargados de proveer streams de datos se escogió la recopilación solamente de imágenes. Bender dispone de variados datos en su memoria de trabajo que son candidatos para ser almacenados en la memoria semántica, como por ejemplo: el sonido percibido en su micrófono, las nubes de puntos 3D percibidas por su sensor de profundidad, o los posiciones de sus efectores. Sin embargo, el almacenamiento de imágenes es muy útil, pues sirve para la demostración final, permite visualizar lo sucedido en el episodio, y la implementación puede servir para otras plataformas, pues las cámaras de video son un sensor muy común en las plataformas robóticas domésticas. Por motivos prácticos, se consideran dos versiones a implementar, una con información ficticia y otra que recopila datos desde el robot real.

\todoimplementation{Proveer plugin agnóstico al robot, configurable a través de parámetros.}

Se utilizará la estrategia de funcionamiento propuesta en la Sección \ref{}, mediante el uso de un \textit{buffer} para almacenar las últimas imágenes percibidas. Luego, el plugin deberá entregar un vector con las imágenes asociadas al lapso episódico requerido. Además, el plugin deberá proveer una API para insertar, buscar, actualizar y borrar mensajes de la colección.
% - ... revisar implementación ...

% SOBRE: plugin dummy
La ``versión de prueba'' debe proveer imágenes obtenidas a partir de un archivo de video. Análogamente a los plugins anteriores, la motivación para esto, es poder acelerar la implementación del proyecto y poder ejecutar validaciones sin requerir el robot real.

% SOBRE Plugin a partir de cámara de cabeza.. una o dos cámaras...
La segunda versión debe ser integrada en el software robot, utilizando la API ROS para leer imágenes desde sus cámaras de video.

%% =============================================================================
%% =============================================================================
%% =============================================================================
\subsection{Plugins para entidades}
%% =============================================================================
%% =============================================================================
%% =============================================================================
%% =====================================================================================

Para los plugins encargados de definir entidades y recopilar sus cambios durante un episodio, se escogieron las entidades de ``Persona'' y ``Objeto''. Ésta selección fue realizada, pues son las entidades más utilizadas por el robot Bender, y probablemente las más significativas para todo robot de servicio doméstico. Otras entidades de alta relevancia que pueden ser consideradas como trabajo futuro, son las de ``Lugar'' y del ``Robot''. De manera similar al caso de los streams, se consideran dos versiones a implementar, una capaz de proveer información ficticia sobre cada entidad, y otra encargada de proveer información real recopilada por el robot.

\todopaused{Requiere implementación funcional de plugin para entidades.}


% SOBRE: requerimientos del server
% - sobre marcar inicio, fin
% - sobre definición de colecciones
% - sobre manejo de la colección: CRUD
% - sobre API ROS asociada.


% SOBRE: Funcionamiento
% - estrtategia de procesamiento
% - buffer
% - periodicidad
% - ... revisar implementación ...

% SOBRE: plugin dummy
% - motivación.. sirve para simulación y pruebas, sin tener acceso al robot.
% - generación de stream de imágenes a partir de un video

% SOBRE Plugin a partir de cámara de cabeza.. una o dos cámaras...
% - sobre eso, siguiendo estrategia definida.













